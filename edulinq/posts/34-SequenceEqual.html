<html>
<head>
<title>Reimplementing LINQ to Objects: Part 34 - SequenceEqual</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 34 - SequenceEqual</h1>
<p>Nearly there now...</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.sequenceequal.aspx">SequenceEqual</a> has two overloads - the obvious two given that we&#39;re dealing with equality:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> SequenceEqual&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> SequenceEqual&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer) </div>  <p>The purpose of the operator is to determine if two sequences are equal; that is, if they consist of the same elements, in the same order. A custom equality comparer can be used to compare each individual pair of elements. Characteristics:</p>  <ul>   <li>The first and second parameters mustn&#39;t be null, and are validated immediately. </li>    <li>The comparer parameter can be null, in which case the default equality comparer for TSource is used. </li>    <li>The overload without a comparer uses the default equality comparer for TSource (no funny discrepancies if ICollection&lt;T&gt; instances are involved, this time). </li>    <li>It uses immediate execution. </li>    <li>It returns as soon as it notices a difference, without evaluating the rest of either sequence. </li> </ul>  <p>So far, so good. Note that no optimizations are mentioned above. There are questions you might consider:</p>  <ul>   <li>Should foo.SequenceEqual(foo) always return true? </li>    <li>If either or both of the sequences implements another collection interface, does that help us? </li> </ul>  <p>The first question sounds like it should be a no-brainer, but it&#39;s not as simple as it sounds. Suppose we have a sequence which always generates 10 random numbers. Is it equal to itself? If you iterate over it twice, you&#39;ll usually get different results. What about a sequence which explicitly changes each time you iterate over it, based on some side-effect? Both the .NET and Edulinq implementations say that these are non-equal. (The random case is interesting, of course - it <em>could</em> happen to yield the same elements as we iterate over the two sequences.)</p>  <p>The second question feels a little simpler to me. We can&#39;t take a shortcut to returning true, but it seems reasonably obvious to me that if you have two collections which allow for a fast &quot;count&quot; operation, and the two counts are different, then the sequences are unequal. Unfortunately, LINQ to Objects appears <em>not</em> to optimize for this case: if you create two huge arrays of differing sizes but equal elements as far as possible, it will take a long time for SequenceEqual to return false. Edulinq <em>does</em> perform this optimization. Note that just having <em>one</em> count isn&#39;t useful: you might expect it to, but it turns out that by the time we could realize that the lengths were different in that case, we&#39;re about to find that out in the &quot;normal&quot; fashion anyway, so there&#39;s no point in complicating the code to make use of the information.</p>  <h3>What are we going to test?</h3>  <p>As well as the obvious argument validation, I have tests for:</p>  <ul>   <li>Collections of different lengths </li>    <li>Ranges of different lengths, both with first shorter than second and vice versa </li>    <li>Using a null comparer </li>    <li>Using a custom comparer </li>    <li>Using no comparer </li>    <li>Equal arrays </li>    <li>Equal ranges </li>    <li>The non-optimization of foo.SequenceEquals(foo) (using side-effects) </li>    <li>The optimization using Count (fails on LINQ to Objects) </li>    <li>Ordering: { 1, 2 } should not be equal to { 2, 1 } </li>    <li>The use of a HashSet&lt;string&gt; with a case-insensitive comparer: the default (case-sensitive) comparer is still used when no comparer is provided </li>    <li>Infinite first sequence with finite second sequence, and vice versa </li>    <li>Sequences which differ just before they would go bang </li> </ul>  <p>None of the test code is particularly interesting, to be honest.</p>  <h3>Let&#39;s implement it!</h3>  <p>I&#39;m not going to show the comparer-less overoad, as it just delegates to the one with a comparer.</p>  <p>Before we get into the guts of SequenceEqual, it&#39;s time for a bit of refactoring. If we&#39;re going to optimize for count, we&#39;ll need to perform the same type tests as Count() twice. That would be horrifically ugly inline, so let&#39;s extract the functionality out into a private method (which Count() can then call as well):</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> TryFastCount&lt;TSource&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="MethodParameter">out</span>&#160;<span class="ValueType">int</span> count)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Optimization for ICollection&lt;T&gt;</span>     <br />&#160;&#160;&#160; ICollection&lt;TSource&gt; genericCollection = source <span class="Keyword">as</span> ICollection&lt;TSource&gt;;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (genericCollection != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; count = genericCollection.Count;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">true</span>;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Optimization for ICollection</span>     <br />&#160;&#160;&#160; ICollection nonGenericCollection = source <span class="Keyword">as</span> ICollection;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (nonGenericCollection != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; count = nonGenericCollection.Count;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">true</span>;     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="InlineComment">// Can&#39;t retrieve the count quickly. Oh well.</span>     <br />&#160;&#160;&#160; count = 0;     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />} </div>  <p>Pretty simple. Note that we <em>always</em> have to set the out parameter to some value. We use 0 on failure - which happens to work out nicely in the Count, as we can just start incrementing if TryFastCount has returned false.</p>  <p>Now we can make a start on SequenceEqual. Here&#39;s the skeleton before we start doing the real work:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> SequenceEqual&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSource&gt; second,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (first == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;first&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (second == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;second&quot;</span>);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="ValueType">int</span> count1;     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count2;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (TryFastCount(first, <span class="MethodParameter">out</span> count1) &amp;&amp; TryFastCount(second, <span class="MethodParameter">out</span> count2))     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (count1 != count2)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; comparer = comparer ?? EqualityComparer&lt;TSource&gt;.Default;     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Main part of implementation goes here</span>     <br />} </div>  <p>I <em>could</em> have included the comparison between count1 and count2 within the single &quot;if&quot; condition, like this:</p>  <div class="code"><span class="Statement">if</span> (TryFastCount(first, <span class="MethodParameter">out</span> count1) &amp;&amp;&#160; <br />&#160;&#160;&#160; TryFastCount(second, <span class="MethodParameter">out</span> count2) &amp;&amp;     <br />&#160;&#160;&#160; count1 != count2)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />} </div>  <p>... but I don&#39;t usually like using the values of out parameters like this. The behaviour is well-defined and correct, but it just feels a little ugly to me.</p>  <p>Okay, now let&#39;s implement the &quot;Main part&quot; which at the bottom of the skeleton. The idea is simple:</p>  <ul>   <li>Get the iterators for both sequences </li>    <li>Use the iterators &quot;in parallel&quot; (not in the multithreading sense, but in the movement of the logical cursor down the sequence) to compare pairs of elements; we can return false if we ever see an unequal pair </li>    <li>If we ever see that one sequence has finished and the other hasn&#39;t, we can return false </li>    <li>If we get to the end of both sequences in the same iteration, we can return true </li> </ul>  <p>I&#39;ve got three different ways of representing the basic algorithm in code though. Fundamentally, the problem is that we don&#39;t have a way of iterating over pairs of elements in two sequences with foreach - we can&#39;t use one foreach loop inside another, for hopefully obvious reasons. So we&#39;ll have to call GetEnumerator() explicitly on <em>at least one</em> of the sequences... and we could do it for both if we want.</p>  <p>The first implementation (and my least favourite) <em>does</em> use a foreach loop:</p>  <div class="code"><span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator2 = second.GetEnumerator())     <br />{     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item1 <span class="Statement">in</span> first)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// second is shorter than first</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator2.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!comparer.Equals(item1, iterator2.Current))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="InlineComment">// If we can get to the next element, first was shorter than second.</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// Otherwise, the sequences are equal.</span>     <br />&#160;&#160;&#160; <span class="Statement">return</span> !iterator2.MoveNext();     <br />} </div>  <p>I don&#39;t have a desperately good reason for picking them this way round (i.e. foreach over first, and GetEnumerator() on second) other than that it seems to still give primacy to first somehow... only first gets the &quot;special treatment&quot; of a foreach loop. (I can almost hear the chants now, &quot;Equal rights for second sequences! Don&#39;t leave us out of the loop! Stop just &#39;using&#39; us!&quot;) Although I&#39;m being frivolous, I dislike the asymmetry of this.</p>  <p>The second attempt is a half-way house: it&#39;s still asymmetric, but slightly less so as we&#39;re explicitly fetching both iterators:</p>  <div class="code"><span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator1 = first.GetEnumerator(),     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; iterator2 = second.GetEnumerator())     <br />{     <br />&#160;&#160;&#160; <span class="Statement">while</span> (iterator1.MoveNext())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// second is shorter than first</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator2.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!comparer.Equals(iterator1.Current, iterator2.Current))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="InlineComment">// If we can get to the next element, first was shorter than second.</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// Otherwise, the sequences are equal.</span>     <br />&#160;&#160;&#160; <span class="Statement">return</span> !iterator2.MoveNext();     <br />} </div>  <p>Note the use of the multi-variable &quot;using&quot; statement; this is equivalent nesting one statement inside another, of course.</p>  <p>The similarities between these two implementations are obvious - but the differences are worth pointing out. In the latter approach, we call MoveNext() on both sequences, and then we access the Current property on both sequences. In each case we use iterator1 before iterator2, but it still feels like they&#39;re being treated more equally somehow. There&#39;s still the fact that iterator1 is being used in the while loop condition, whereas iterator2 has to be used both inside and outside the while loop. Hmm.</p>  <p>The third implementation takes this even further, changing the condition of the while loop:</p>  <div class="code"><span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator1 = first.GetEnumerator(),     <br />&#160;&#160;&#160;&#160;&#160;&#160; iterator2 = second.GetEnumerator())     <br />{     <br />&#160;&#160;&#160; <span class="Statement">while</span> (<span class="Keyword">true</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">bool</span> next1 = iterator1.MoveNext();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">bool</span> next2 = iterator2.MoveNext();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Sequences aren&#39;t of same length. We don&#39;t</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// care which way round.</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (next1 != next2)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Both sequences have finished - done</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!next1)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">true</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!comparer.Equals(iterator1.Current, iterator2.Current))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; } </div>  <p>This feels about as symmetric as we can get. The use of next1 in the middle &quot;if&quot; condition is incidental - it could just as easily be next2, as we know the values are equal. We could switch round the order of the calls to MoveNext(), the order of arguments to comparer.Equals - the <em>structure</em> is symmetric.</p>  <p>I&#39;m not generally a fan of while(true) loops, but in this case I think I rather like it. It makes it obvious that we&#39;re going to keep going until we&#39;ve got a good reason to stop: one of the three return statements. (I suppose I should apologise to fans of the dogma around single exit points for methods, if any are reading. This must be hell for you...)</p>  <p>Arguably this is all a big fuss about nothing - but writing Edulinq has given me a new appreciation for diving into this level of detail to find the most readable code. As ever, I&#39;d be interested to hear your views. (All three versions are in source control. Which one is active is defined with a #define.)</p>  <h3>Conclusion</h3>  <p>I really don&#39;t know why Microsoft didn&#39;t implement the optimization around different lengths for SequenceEqual. Arguably in the context of LINQ you&#39;re <em>unlikely</em> to be dealing with two materialized collections at a time - it&#39;s much more common to have one collection and a lazily-evaluated query, or possibly just two queries... but it&#39;s a cheap optimization and the benefits can be significant. <em>Maybe</em> it was just an oversight.</p>  <p>Our next operator also deals with pairs of elements, so we may be facing similar readability questions around it. It&#39;s Zip - the only new LINQ query operator in .NET 4.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
