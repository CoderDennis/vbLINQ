<html>
<head>
<title>Reimplementing LINQ to Objects: Part 2 - &quot;Where&quot;</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 2 - Where</h1>
<p>Warning: this post is quite long. Although I&#39;ve chosen a simple operator to implement, we&#39;ll encounter a few of the corner cases and principles involved in LINQ along the way. This will also be a somewhat experimental post in terms of format, as I try to work out the best way of presenting the material.</p>  <p>We&#39;re going to implement the &quot;Where&quot; clause/method/operator. It&#39;s reasonably simple to understand in general, but goes into all of the deferred execution and streaming bits which can cause problems. It&#39;s generic, but only uses one type parameter (which is a big deal, IMO - the more type parameters a method has, the harder I find it to understand in general). Oh, and it&#39;s a starting point for query expressions, which is a bonus.</p>  <h3><strong>What is it?</strong></h3>  <p>&quot;<a href="http://msdn.microsoft.com/en-us/library/bb301979.aspx">Where</a>&quot; has two overloads:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Where(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)    <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Where(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>, <span class="ValueType">bool</span>&gt; predicate) </div>  <p>Before I go into what it actually does, I&#39;ll point out a few things which are going to be common across nearly all of the LINQ operators we&#39;ll be implementing:</p>  <ul>   <li>These are <em><a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">extension methods</a></em> - they&#39;re declared in a top-level, non-nested, static class and the first parameter has a &quot;this&quot; modifier. They can be invoked roughly as if they were instance methods on the type of the first parameter. </li>    <li>They&#39;re <em><a href="http://msdn.microsoft.com/en-us/library/twcad0zb.aspx">generic methods</a></em> - in this case there&#39;s just a single type parameter (TSource) which indicates the type of sequence we&#39;re dealing with. So for (say) a list of strings, TSource would be string. </li>    <li>They take <em>generic delegates</em> in the Func&lt;...&gt; family. These are usually specified with <a href="http://msdn.microsoft.com/en-us/library/bb397687.aspx">lambda expressions</a>, but any other way of providing a delegate will work fine too. </li>    <li>They deal with <em>sequences</em>. These are represented by <a href="http://msdn.microsoft.com/en-us/library/9eekhta0.aspx">IEnumerable&lt;T&gt;</a>, with an iterator over a sequence being represented by <a href="http://msdn.microsoft.com/en-us/library/78dfe2yb.aspx">IEnumerator&lt;T&gt;</a>. </li> </ul>  <p>I fully expect that most readers will be comfortable with all of these concepts, so I won&#39;t go into them in more detail. If any of the above makes you nervous, please familiarise yourself with them before continuing, otherwise you&#39;re likely to have a hard time.</p>  <p>The purpose of &quot;Where&quot; is to filter a sequence. It takes an input sequence and a <em>predicate</em>, and returns another sequence. The output sequence is of the same element type (so if you put in a sequence of strings, you&#39;ll get a sequence of strings out) and it will only contain elements from the input sequence which pass the predicate. (Each item will be passed to the predicate in turn. If the predicate returns true, the item will be part of the output sequence; otherwise it won&#39;t.)</p>  <p>Now, a few important details about the behaviour:</p>  <ul>   <li>The input sequence is <em>not</em> modified in any way: this isn&#39;t like <a href="http://msdn.microsoft.com/en-us/library/wdka673a.aspx">List&lt;T&gt;.RemoveAll</a>, for example. </li>    <li>The method uses <em>deferred execution</em> - until you start trying to fetch items from the output sequence, it won&#39;t start fetching items from the input sequence </li>    <li>Despite deferred execution, it will validate that the parameters aren&#39;t null immediately </li>    <li>It <em>streams</em> its results: it only ever needs to look at one result at a time, and will yield it without keeping a reference to it. This means you can apply it to an infinitely long sequence (for example a sequence of random numbers) </li>    <li>It will iterate over the input sequence exactly once each time you iterate over the output sequence </li>    <li>Disposing of an iterator over the output sequence will dispose of the corresponding iterator over the input sequence. (In case you didn&#39;t realise, the foreach statement in C# uses a try/finally block to make sure the iterator is always disposed however the loop finishes.) </li> </ul>  <p>Many of these points will be true for a lot of our other operators too.</p>  <p>The overload which takes a Func&lt;TSource, int, bool&gt; lets the predicate use the index within the sequence as well as the value. The index always starts at 0, and increments by 1 each time regardless of previous results from the predicate.</p>  <h3>What are we going to test?</h3>  <p>Ideally, we&#39;d like to test <em>all</em> of the points above. The details of streaming and how many times the sequence is iterated over are frankly a pain to deal with, unfortunately. Given how much there is to implement already, we&#39;ll come back to those.</p>  <p>Let&#39;s have a look at some tests. First, here&#39;s a simple &quot;positive&quot; test - we&#39;re starting with an array of integers, and using a lambda expression to only include elements less than 4 in the output. (The word &quot;filter&quot; is omnipresent but unfortunate. It&#39;s easier to talk about &quot;filtering out&quot; elements than &quot;including&quot; them, but the predicate is expressed in a <em>positive</em> way.)</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SimpleFiltering()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] source = { 1, 3, 4, 2, 8, 1 };     <br />&#160;&#160;&#160; <span class="Linq">var</span> result = source.Where(x =&gt; x &lt; 4);     <br />&#160;&#160;&#160; result.AssertSequenceEqual(1, 3, 2, 1);     <br />} </div>  <p>I&#39;ve kept the TestExtensions from MoreLINQ, despite NUnit coming with <a href="http://www.nunit.org/index.php?p=collectionAssert&amp;r=2.5">CollectionAssert</a>. I find the extension methods easier to work with for three reasons:</p>  <ul>   <li>They&#39;re extension methods, which helps to reduce the clutter </li>    <li>They can use a parameter array for the expected output, which makes the test simpler to express </li>    <li>The message is clearer when the assertion fails </li> </ul>  <p>Basically, AssertSequenceEqual does what you&#39;d expect it to - it checks that the actual result (usually expressed as the variable you call the method on) matches the expected result (usually expressed as a parameter array).</p>  <p>So far, so good. Now let&#39;s check argument validation:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> NullSourceThrowsNullArgumentException()     <br />{     <br />&#160;&#160;&#160; IEnumerable&lt;<span class="ValueType">int</span>&gt; source = <span class="Keyword">null</span>;     <br />&#160;&#160;&#160; Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; source.Where(x =&gt; x &gt; 5));     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> NullPredicateThrowsNullArgumentException()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] source = { 1, 3, 7, 9, 10 };     <br />&#160;&#160;&#160; Func&lt;<span class="ValueType">int</span>, <span class="ValueType">bool</span>&gt; predicate = <span class="Keyword">null</span>;     <br />&#160;&#160;&#160; Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; source.Where(predicate));     <br />} </div>  <p>I&#39;m not bothering to check the name within the ArgumentNullException, but importantly I&#39;m testing that the arguments are being validated immediately. I&#39;m not trying to iterate over the result - so if the validation is deferred, the test will fail.</p>  <p>The final interesting test for the moment is also around deferred execution, using a helper class called ThrowingEnumerable. This is a sequence which blows up with an InvalidOperationException if you ever try to iterate over it. Essentially, we want to check two things:</p>  <ul>   <li>Just calling Where doesn&#39;t start iterating over the source sequence </li>    <li>When we call GetEnumerator() to get an iterator and then MoveNext() on that iterator, we <em>should</em> start iterating, causing an exception to be thrown. </li> </ul>  <p>We&#39;ll need to do something similar for other operators, so I&#39;ve written a small helper method in ThrowingEnumerable:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">void</span> AssertDeferred&lt;T&gt;(     <br />&#160;&#160;&#160; Func&lt;IEnumerable&lt;<span class="ValueType">int</span>&gt;, IEnumerable&lt;T&gt;&gt; deferredFunction)     <br />{     <br />&#160;&#160;&#160; ThrowingEnumerable source = <span class="Keyword">new</span> ThrowingEnumerable();     <br />&#160;&#160;&#160; <span class="Linq">var</span> result = deferredFunction(source);     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> iterator = result.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; iterator.MoveNext());     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Now we can use that to check that Where really defers execution:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> ExecutionIsDeferred()     <br />{     <br />&#160;&#160;&#160; ThrowingEnumerable.AssertDeferred(src =&gt; src.Where(x =&gt; x &gt; 0));     <br />} </div>  <p>These tests have all dealt with the simpler predicate overload - where the predicate is only passed the item, not the index. The tests involving the index are very similar.</p>  <h3>Let&#39;s implement it!</h3>  <p>With all the tests passing when running against the real LINQ to Objects, it&#39;s time to implement it in our production code. We&#39;re going to use <a href="http://msdn.microsoft.com/en-us/library/dscyy5s0.aspx">iterator blocks</a>, which were introduced in C# 2 to make it easier to implement IEnumerable&lt;T&gt;. I have a <a href="http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx">couple</a> of <a href="http://csharpindepth.com/Articles/Chapter6/IteratorBlockImplementation.aspx">articles</a> you can read if you want more background details... or read chapter 6 of C# in Depth (either edition). These give us deferred execution for free... but that can be a curse as well as a blessing, as we&#39;ll see in a minute.</p>  <p>At its heart, the implementation is going to look something like this:</p>  <div class="code"><span class="InlineComment">// Naive implementation</span>     <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Simple, isn&#39;t it? Iterator blocks allow us to write the code pretty much how we&#39;d describe it: we iterate over each item in the source, and if the predicate returns true for that particular item, we yield (include) it in the output sequence.</p>  <p>Lo and behold, some of our tests pass already. Now we just need argument validation. That&#39;s easy, right? Let&#39;s give it a go:</p>  <div class="code"><span class="InlineComment">// Naive validation - broken!</span>     <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (predicate == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Hmm. Our validation tests still seem to be red, and putting a breakpoint on the &quot;throw&quot; statements doesn&#39;t help... they&#39;re not getting hit. What&#39;s going on?</p>  <p>I&#39;ve given a few pretty broad hints already. The problem is deferred execution. Until we start trying to iterate over the result, <em>none of our code will run</em>. Our tests deliberately <em>don&#39;t</em> iterate over the result, so validation is never performed.</p>  <p>We&#39;ve just hit a design flaw in C#. Iterator blocks in C# simply don&#39;t work nicely when you want to split execution between &quot;immediate&quot; (usually for validation) and &quot;deferred&quot;. Instead, we have to split our implementation into two: a normal method for validation, which then calls the iterator method for the deferred processing:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (predicate == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> WhereImpl(source, predicate);     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; WhereImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>It&#39;s ugly, but it works: all our index-less tests go green. From here, it&#39;s a short step to implement the version using an index as well:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;T, <span class="ValueType">int</span>, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (predicate == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> WhereImpl(source, predicate);     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; WhereImpl&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">int</span>, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span> index = 0;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item, index))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; index++;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Now the bar is green, and we&#39;re done. Hang on though... we haven&#39;t used it every way we can yet.</p>  <h3>Query expressions</h3>  <p>So far, we&#39;ve been calling the method directly (although as an extension method) - but LINQ also provides us with query expressions. Here&#39;s our &quot;SimpleFiltering&quot; test rewritten to use a query expression:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> QueryExpressionSimpleFiltering()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] source = { 1, 3, 4, 2, 8, 1 };     <br />&#160;&#160;&#160; <span class="Linq">var</span> result = <span class="Linq">from</span> x <span class="Statement">in</span> source     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">where</span> x &lt; 4     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> x;     <br />&#160;&#160;&#160; result.AssertSequenceEqual(1, 3, 2, 1);     <br />} </div>  <p></p>  <p>(Note that the name is different here to in the downloadable code, to stop the blog server software blocking the name of the method. Grr.)</p>  <p>That will produce <em>exactly</em> the same code as our earlier test. The compiler basically translates this form into the previous one, leaving the condition (x &lt; 4) as a lambda expression and then converting it appropriately (into a delegate in this case). You may be surprised that this works as we have no Select method yet...&#160; but in this case we have a &quot;no-op&quot; select projection; we&#39;re not actually performing a real transformation. In that case - and so long as there&#39;s <em>something</em> else in the query, in this case our &quot;where&quot; clause - the compiler effectively omits the &quot;select&quot; clause, so it doesn&#39;t matter that we haven&#39;t implemented it. If you changed &quot;select x&quot; to &quot;select x * 2&quot;, it would fail to compile against our Where-only LINQ implementation.</p>  <p>The fact that query expressions are just based on patterns like this is a very powerful feature for flexibility - it&#39;s how LINQ to Rx is able to only implement the operators that make sense in that environment, for example. Similarly, there&#39;s nothing in the C# compiler that &quot;knows&quot; about IEnumerable&lt;T&gt; when it comes to query expressions - which is how entirely separate interfaces such as IObservable&lt;T&gt; work just as well.</p>  <h3>What have we learned?</h3>  <p>There&#39;s been a lot to take in here, in terms of both implementation and core LINQ principles:</p>  <ul>   <li>LINQ to Objects is based on extension methods, delegates and IEnumerable&lt;T&gt; </li>    <li>Operators use deferred execution where appropriate and stream their data where possible </li>    <li>Operators don&#39;t mutate the original source, but instead return a new sequence which will return the appropriate data </li>    <li>Query expressions are based on compiler translations of patterns; you don&#39;t need to implement any more of the pattern than the relevant query expression requires </li>    <li>Iterator blocks are great for implementing deferred execution... </li>    <li>... but make eager argument validation a pain </li> </ul>  <h3>Code download</h3>  <p><a href="http://yoda.arachsys.com/blogfiles/csharp/l2o/Linq-To-Objects-2.zip">Linq-To-Objects-2.zip</a></p>  <p>Many people have asked for a source repository for the project, and that makes sense. I&#39;m putting it together a source repository for it now; it&#39;s likely to be done before I post the next part.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
