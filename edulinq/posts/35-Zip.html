<html>
<head>
<title>Reimplementing LINQ to Objects: Part 35 - Zip</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 35 - Zip</h1>
<p>Zip will be a familiar operator to any readers who use Python. It was introduced in .NET 4 - it&#39;s not entirely clear why it wasn&#39;t part of the first release of LINQ, to be honest. Perhaps no-one thought of it as a useful operator until it was too late in the release cycle, or perhaps implementing it in the other providers (e.g. LINQ to SQL) took too long. Eric Lippert <a href="http://blogs.msdn.com/b/ericlippert/archive/2009/05/07/zip-me-up.aspx">blogged about it in 2009</a>, and I find it interesting to note that aside from braces, layout and names we&#39;ve got exactly the same code. (I read the post at the time of course, but implemented it tonight without looking back at what Eric had done.) It&#39;s not exactly surprising, given how trivial the implementation is. Anyway, enough chit-chat...</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/dd267698.aspx">Zip</a> has a single signature, which isn&#39;t terribly complicated:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TFirst&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSecond&gt; second,     <br />&#160;&#160;&#160; Func&lt;TFirst, TSecond, TResult&gt; resultSelector) </div>  <p>Just from the signature, the name, and experience from the rest of this blog series it should be easy enough to guess what Zip does:</p>  <ul>   <li>It uses deferred execution, not reading from either sequence until the result sequence is read </li>    <li>All three parameters must be non-null; this is validated eagerly </li>    <li>Both sequences are iterated over &quot;at the same time&quot;: it calls GetEnumerator() on each sequence, then moves each iterator forward, then reads from it, and repeats. </li>    <li>The result selector is applied to each pair of items obtained in this way, and the result yielded </li>    <li>It stops when <em>either</em> sequence terminates </li>    <li>As a natural consequence of how the sequences are read, we don&#39;t need to perform any buffering: we only care about one element from each sequence at a time. </li> </ul>  <p>There are really only two things that I could see might have been designed differently:</p>  <ul>   <li>It could have just returned IEnumerable&lt;Tuple&lt;TFirst, TSecond&gt;&gt; but that would have been less efficient in many cases (in terms of the GC) and inconsistent with the rest of LINQ </li>    <li>It could have provided different options for what to do with sequences of differents lengths. For example:      <ul>       <li>Throw an exception </li>        <li>Use the default value of the shorter sequence type against the remaining items of the longer sequence </li>        <li>Use a <em>specified</em> default value of the shorter sequence in the same way </li>     </ul>   </li> </ul>  <p>I don&#39;t have any problem with the design that&#39;s been chosen here though.</p>  <h3>What are we going to test?</h3>  <p>There are no really interesting test cases here. We test argument validation, deferred execution, and the obvious &quot;normal&quot; cases. I do have tests where &quot;first&quot; is longer than &quot;second&quot; and vice versa.</p>  <p>The one test case which is noteworthy isn&#39;t really present for the sake of testing at all - it&#39;s to demonstrate a technique which can occasionally be handy. Sometimes we really want to perform a projection on adjacent pairs of elements. Unfortunately there&#39;s no LINQ operator to do this naturally (although it&#39;s easy to write one) but Zip can provide a workaround, so long as we don&#39;t mind evaluating the sequence twice. (That could be a problem in some cases, but is fine in others.)</p>  <p>Obviously if you just zip a sequence with itself directly you get each element paired with the same one. We effectively need to &quot;shift&quot; or &quot;delay&quot; one sequence somehow. We can do this using Skip, as shown in this test:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> AdjacentElements()     <br />{     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] elements = { <span class="String">&quot;a&quot;</span>, <span class="String">&quot;b&quot;</span>, <span class="String">&quot;c&quot;</span>, <span class="String">&quot;d&quot;</span>, <span class="String">&quot;e&quot;</span> };     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = elements.Zip(elements.Skip(1), (x, y) =&gt; x + y);     <br />&#160;&#160;&#160; query.AssertSequenceEqual(<span class="String">&quot;ab&quot;</span>, <span class="String">&quot;bc&quot;</span>, <span class="String">&quot;cd&quot;</span>, <span class="String">&quot;de&quot;</span>);     <br />} </div>  <p>It always takes me a little while to work out whether I want to make first skip or second - but if we want the second element as the first element of second (try getting that right ten times in a row - it makes sense, honest!) means that we want to call Skip on the sequence used as the argument for second. Obviously it would work the other way round too - we&#39;d just get the pairs presented with the values switched, so the results of the query above would be &quot;ba&quot;, &quot;cb&quot; etc.</p>  <h3>Let&#39;s implement it!</h3>  <p>Guess what? It&#39;s yet another operator with a split implementation between the argument validation and the &quot;real work&quot;. I&#39;ll skip argument validation, and get into the tricky stuff. Are you ready? Sure you don&#39;t want another coffee?</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; ZipImpl&lt;TFirst, TSecond, TResult&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TFirst&gt; first,     <br />&#160;&#160;&#160; IEnumerable&lt;TSecond&gt; second,     <br />&#160;&#160;&#160; Func&lt;TFirst, TSecond, TResult&gt; resultSelector)     <br />{     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TFirst&gt; iterator1 = first.GetEnumerator())     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSecond&gt; iterator2 = second.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator1.MoveNext() &amp;&amp; iterator2.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> resultSelector(iterator1.Current, iterator2.Current);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Okay, so possibly &quot;tricky stuff&quot; was a bit of an overstatement. Just about the only things to note are:</p>  <ul>   <li>I&#39;ve &quot;stacked&quot; the using statements instead of putting the inner one in braces and indenting it. For using statements with different variable types, this is one way to keep things readable, although it can be a pain when tools try to reformat the code. (Also, I don&#39;t <em>usually</em> omit optional braces like this. It does make me feel a bit dirty.) </li>    <li>I&#39;ve used the &quot;symmetric&quot; approach again instead of a using statement with a foreach loop inside it. That wouldn&#39;t be <em>hard</em> to do, but it wouldn&#39;t be as simple. </li> </ul>  <p>That&#39;s just about it. The code does exactly what it looks like, which doesn&#39;t make for a very interesting blog post, but does make for good readability.</p>  <h3>Conclusion</h3>  <p>Two operators to go, one of which I might not even tackle fully (AsQueryable - it <em>is</em> part of Queryable rather than Enumerable, after all).</p>  <p>AsEnumerable should be pretty easy...</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
