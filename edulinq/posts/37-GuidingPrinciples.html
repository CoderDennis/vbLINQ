<html>
<head>
<title>Reimplementing LINQ to Objects: Part 37 - Guiding principles</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 37 - Guiding principles</h1>
<p>Now that I&#39;m &quot;done&quot; reimplementing LINQ to Objects - in that I&#39;ve implemented all the methods in System.Linq.Enumerable - I wanted to write a few posts looking at the bigger picture. I&#39;m not 100% sure of what this will consist of yet; I want to avoid this blog series continuing forever. However, I&#39;m confident it will contain (in no particular order):</p>  <ul>   <li>This post: principles governing the behaviour of LINQ to Objects </li>    <li>Missing operators: what else I&#39;d have liked to see in Enumerable </li>    <li>Optimization: where the .NET implementation could be further optimized, and why some obvious-sounding optimizations may be inappropriate </li>    <li>How query expression translations work, in brief (and with a cheat sheet) </li>    <li>The difference between IQueryable&lt;T&gt; and IEnumerable&lt;T&gt; </li>    <li>Sequence identity, the &quot;Contains&quot; issue, and other knotty design questions </li>    <li>Running the Edulinq tests against other implementations </li> </ul>  <p>If there are other areas you want me to cover, please let me know.</p>  <h3>The principles behind the LINQ to Objects implementation</h3>  <p>The design LINQ to Objects is built on a few guiding principles, both in terms of design and implementation details. You need to understand these, but also implementations should be clear about what they&#39;re doing in these terms too.</p>  <h3>Extension method targets and argument validation</h3>  <p>IEnumerable&lt;T&gt; is the core sequence type, not just for LINQ but for .NET as a whole. Almost <em>everything</em> is written in terms of IEnumerable&lt;T&gt; at least as input, with the following exceptions: </p>  <ul>   <li>Empty, Range and Repeat don&#39;t have input sequences (these are the only non-extension methods) </li>    <li>OfType and Cast work on the non-generic IEnumerable type instead </li>    <li>ThenBy and ThenByDescending work on IOrderedEnumerable&lt;T&gt; </li> </ul>  <p>All operators other than AsEnumerable verify that any input sequence is non-null. This validation is performed eagerly (i.e. when the method is called) even if the operator uses deferred execution for the results. Any delegate used (typically a projection or predicate of some kind) must be non-null. Again, this validation is performed eagerly. </p>  <p>IEqualityComparer&lt;T&gt; is used for all custom equality comparisons. Any parameter of this type <em>may</em> be null, in which case the default equality comparer for the type is used. In <em>most</em> cases the default equality comparer for the type is also used when no custom equality comparer is used, but Contains has some odd behaviour around this. Equality comparers are expected to be able to handle null values. IComparer&lt;T&gt; is <em>only</em> used by the OrderBy/ThenBy operators and their descending counterparts - and only then if you want custom comparisons between keys. Again, a null IComparer&lt;T&gt; means &quot;use the default for the type&quot;</p>  <h3>Timing of input sequence &quot;opening&quot;</h3>  <p>Any operator with a return type of IEnumerable&lt;T&gt; or IOrderedEnumerable&lt;T&gt; uses <em>deferred execution</em>. This means that the method doesn&#39;t read anything from any input sequences until someone starts reading from the result sequence. It&#39;s not clearly defined exactly <em>when</em> input sequences will first be accessed - for some operators if may be when GetEnumerator() is called; for others it may be on the first call to MoveNext() on the resulting iterator. Callers should not depend on these slight variations. Deferred execution is common for operators in the middle of queries. Operators which use deferred execution effectively represent queries rather than the results of queries - so if you change the contents of the original source of the query and then iterate over the query itself again, you&#39;ll see the change. For example:</p>  <div class="code">List&lt;<span class="ReferenceType">string</span>&gt; source = <span class="Keyword">new</span> List&lt;<span class="ReferenceType">string</span>&gt;();     <br /><span class="Linq">var</span> query = source.Select(x =&gt; x.ToUpper());     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="InlineComment">// This loop won&#39;t write anything out</span>     <br /><span class="Statement">foreach</span> (<span class="ReferenceType">string</span> x <span class="Statement">in</span> query)     <br />{     <br />&#160;&#160;&#160; Console.WriteLine(x);     <br />}     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />source.Add(<span class="String">&quot;foo&quot;</span>);     <br />source.Add(<span class="String">&quot;bar&quot;</span>);     <br />    <br /><span class="InlineComment">// This loop will write out &quot;FOO&quot; and &quot;BAR&quot; - even</span>     <br /><span class="InlineComment">// though we haven&#39;t changed the value of &quot;query&quot;</span>     <br /><span class="Statement">foreach</span> (<span class="ReferenceType">string</span> x <span class="Statement">in</span> query)     <br />{     <br />&#160;&#160;&#160; Console.WriteLine(x);     <br />} </div>  <p>Deferred execution is one of the hardest parts of LINQ to understand, but once you do, everything becomes somewhat simpler.</p>  <p>All other operators use <em>immediate execution</em>, fetching all the data they need from the input before they return a value... so that by the time they <em>do</em> return, they will no longer see or care about changes to the input sequence. For operators returning a scalar value (such as Sum and Average) this is blatantly obvious - the value of a variable of type double isn&#39;t going to change just because you&#39;ve added something to a list. However, it&#39;s slightly less for the &quot;ToXXX&quot; methods: ToLookup, ToArray, ToList and ToDictionary. These do <em>not</em> return views on the original sequence, unlike the &quot;As&quot; methods: AsEnumerable which we&#39;ve seen, and Queryable.AsQueryable which I didn&#39;t implement. Focus on the prefix part of the name: the &quot;To&quot; part indicates a conversion to a particular type. The &quot;As&quot; prefix indicates a wrapper of some kind. This is consistent with other parts of the framework, such as List&lt;T&gt;.AsReadOnly and Array.AsReadOnly&lt;T&gt;.</p>  <p>Very importantly, LINQ to Objects only iterates over any input sequence at most <strong>once</strong>, whether the execution is deferred or immediate. Some operators would be easier to implement if you could iterate over the input twice - but it&#39;s important that they don&#39;t do so. Of course if you provide the same sequence for two inputs, it will treat those as logically different sequences. Similarly if you iterate over a result sequence more than once (for operators that return IEnumerable&lt;T&gt; or a related interface, rather than List&lt;T&gt; or an array etc), that will iterate over the input sequence again.</p>  <p>This means it&#39;s fine to use LINQ to Objects with sequences which may only be read once (such as a network stream), or which are relatively expensive to reread (imagine a log file reader over a huge set of logs) or which give inconsistent results (imagine a sequence of random numbers). In some cases it&#39;s okay to use LINQ to Objects with an infinite sequence - in others it&#39;s not. It&#39;s <em>usually</em> fairly obvious which is the case.</p>  <h3>Timing of input sequence reading, and memory usage</h3>  <p>Where possible within deferred execution, operators act in a <em>streaming</em> fashion, only reading from the input sequence when they have to, and &quot;forgetting&quot; data as soon as they can. This allows for long - potentially infinite - sequences to be handled elegantly without memory running out.</p>  <p>Some operators naturally need to read all the data in before they can return anything. The most obvious example of this is Reverse, which will always yield the last element of the input stream as the first element in the result stream.</p>  <p>A third pattern occurs with operators such as Distinct, which yield data as they go, but accumulate elements too, taking more and more memory until the caller stops iterating (usually either by jumping out of the foreach loop, or letting it terminate naturally).</p>  <p>Where an operator takes two input sequences - such as Join - you need to understand the consumption of each one separately. For example, Join uses deferred execution, but as soon as you ask for the first element of the result set, it will read the &quot;second&quot; sequence <em>completely</em> and buffer it - whereas the &quot;first&quot; sequence is streamed. This isn&#39;t the case for all operators with two inputs, of course - Zip streams both input sequences, for example. Check the documentation - and the relevant Edulinq blog post - for details.</p>  <p>Obviously any operator which uses immediate execution has to read all the data it&#39;s interested in before it returns. This doesn&#39;t necessarily mean they will read to the end of the sequence though, and they may not need to buffer the data they read. (Simple examples are ToList which has to keep everything, and Sum which doesn&#39;t.)</p>  <h3>Queries vs data</h3>  <p>Closely related to the details of when the input is read is the concept of what the result of an operator actually represents. Operators which use deferred execution return <em>queries</em>: each time you iterate over the result sequence, the query will look at the input sequence again. The query itself doesn&#39;t contain the data - it just knows how to get at the data.</p>  <p>Operators which use immediate execution work the other way round: they read all the data they need, and then forget about the input sequence. For operators like Average and Sum this is obvious as it&#39;s just a simple scalar value - but for operators like ToList, ToDictionary, ToLookup and ToArray, it means that the operator has to make a copy of everything it needs. (This is potentially a <em>shallow</em> copy of course - depending on what user-defined projections are applied. The normal behaviour of mutable reference types is still valid.)</p>  <p>I realise that in many ways I&#39;ve just said the same thing multiple times now - but hopefully that will help this crucial aspect of LINQ behaviour sink in, if you were still in any doubt.</p>  <h3>Exception handling</h3>  <p>I&#39;m unaware of any situation in which LINQ to Objects will catch an exception. If your predicate or projection throws an exception, it will propagate in the obvious way.</p>  <p>However, LINQ to Objects <em>does</em> ensure that any iterator it reads from is disposed appropriately - assuming that the caller disposes of any result sequences properly, of course. Note that the foreach statement implicitly disposes of the iterator in a finally block.</p>  <h3>Optimization</h3>  <p>Various operators are optimized when they detect at execution time that the input sequence they&#39;re working on offers a shortcut.</p>  <p>The types most commonly detected are:</p>  <ul>   <li>ICollection&lt;T&gt; and ICollection for their Count property </li>    <li>IList&lt;T&gt; for its random access indexer </li> </ul>  <p>I&#39;ll look at optimization in much more detail in a separate post.</p>  <h3>Conclusion</h3>  <p>This post has not been around the guiding principles behind LINQ itself - lambda calculus or anything like that. It&#39;s more been a summary of the various aspects of behaviour we&#39;ve seen across the various operators we&#39;ve implemented. They&#39;re the rules I&#39;ve had to follow in order to make Edulinq reasonably consistent with LINQ to Objects.</p>  <p>Next time I&#39;ll talk about some of the operators which I think <em>should</em> have made it into the core framework, at least for LINQ to Objects.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
