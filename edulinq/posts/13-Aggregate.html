<html>
<head>
<title>Reimplementing LINQ to Objects: Part 13 - Aggregate</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 13 - Aggregate</h1>
<p>EDIT: I&#39;ve had to edit this quite a bit now that a second bug was discovered... basically my implementation of the first overload was completely broken :(</p>  <p>Last night&#39;s tweet asking for suggestions around which operator to implement next resulted in a win for Aggregate, so here we go.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.aggregate.aspx" target="_blank">Aggregate</a> has three overloads, effectively allow two defaults:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Aggregate&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TSource, TSource&gt; func)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TAccumulate seed,     <br />&#160;&#160;&#160; Func&lt;TAccumulate, TSource, TAccumulate&gt; func)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TAccumulate seed,     <br />&#160;&#160;&#160; Func&lt;TAccumulate, TSource, TAccumulate&gt; func,     <br />&#160;&#160;&#160; Func&lt;TAccumulate, TResult&gt; resultSelector) </div>  <p>Aggregate is an extension method using immediate execution, returning a single result. The generalised behaviour is as follows:</p>  <ul>   <li>Start off with a <em>seed</em>. For the first overload, this defaults to the first value of the input sequence. The seed is used as the first <em>accumulator</em> value. </li>    <li>For each item in the list, apply the aggregation function, which takes the current accumulator value and the newly found item, and returns a new accumulator value. </li>    <li>Once the sequence has been exhausted, optionally apply a final projection to obtain a result. If no projection has been specified, we can imagine that the identity function has been provided. </li> </ul>  <p>The signatures make all of this look a bit more complicated because of the various type parameters involved. You can consider all the overloads as dealing with three different types, even though the first two actually have fewer type parameters:</p>  <ul>   <li>TSource is the element type of the sequence, always. </li>    <li>TAccumulate is the type of the accumulator - and thus the seed. For the first overload where no seed is provided, TAccumulate is effectively the same as TSource. </li>    <li>TResult is the return type when there&#39;s a final projection involved. For the first two overloads, TResult is effectively the same as TAccumulate (again, think of a default &quot;identity projection&quot; as being used when nothing else is specified) </li> </ul>  <p>In the first overload, which uses the first input element as the seed, an InvalidOperationException is thrown if the input sequence is empty.</p>  <h3>What are we going to test?</h3>  <p>Obviously the argument validation is reasonably simple to test - source, func and resultSelector can&#39;t be null. But there are two different approaches to testing the &quot;success&quot; cases.</p>  <p>We <em>could</em> work out exactly when each delegate should be called and with what values - effectively mock every step of the iteration. This would be a bit of a pain, but a very robust way of proceeding.</p>  <p>The alternative approach is just to take some sample data and aggregation function, work out what the result should be, and assert that result. If the result is sufficiently unlikely to be achieved by chance, this is probably good enough - and it&#39;s a lot simpler to implement. Here&#39;s a sample from the most complicated test, where we have a seed and a final projection:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SeededAggregationWithResultSelector()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] source = { 1, 4, 5 };     <br />&#160;&#160;&#160; <span class="ValueType">int</span> seed = 5;     <br />&#160;&#160;&#160; Func&lt;<span class="ValueType">int</span>, <span class="ValueType">int</span>, <span class="ValueType">int</span>&gt; func = (current, value) =&gt; current * 2 + value;     <br />&#160;&#160;&#160; Func&lt;<span class="ValueType">int</span>, <span class="ReferenceType">string</span>&gt; resultSelector = result =&gt; result.ToInvariantString();     <br />&#160;&#160;&#160; <span class="InlineComment">// First iteration: 5 * 2 + 1 = 11</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// Second iteration: 11 * 2 + 4 = 26</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// Third iteration: 26 * 2 + 5 = 57</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// Result projection: 57.ToString() = &quot;57&quot;</span>     <br />&#160;&#160;&#160; Assert.AreEqual(<span class="String">&quot;57&quot;</span>, source.Aggregate(seed, func, resultSelector));     <br />} </div>  <p>Now admittedly I&#39;m not testing this to the absolute full - I&#39;m using the same types for TSource and TAccumulate - but frankly it gives me plenty of confidence that the implementation is correct.</p>  <p>EDIT: My result selector now calls ToInvariantString. It used to just call ToString, but as I&#39;ve now been persuaded that there are some cultures where that wouldn&#39;t give us the right results, I&#39;ve implemented an extension method which effectively means that x.ToInvariantString() is equivalent to x.ToString(CultureInfo.InvariantCulture) - so we don&#39;t need to worry about cultures with different numeric representations etc.</p>  <p>Just for the sake of completeness (I&#39;ve convinced myself to improve the code while writing this blog post), here&#39;s an example which sums integers, but results in a long - so it copes with a result which is bigger than Int32.MaxValue. I haven&#39;t bothered with a final projection though:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> DifferentSourceAndAccumulatorTypes()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span> largeValue = 2000000000;     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] source = { largeValue, largeValue, largeValue };     <br />&#160;&#160;&#160; <span class="ValueType">long</span> sum = source.Aggregate(0L, (acc, value) =&gt; acc + value);     <br />&#160;&#160;&#160; Assert.AreEqual(6000000000L, sum);     <br />&#160;&#160;&#160; <span class="InlineComment">// Just to prove we haven&#39;t missed off a zero...</span>     <br />&#160;&#160;&#160; Assert.IsTrue(sum &gt; <span class="ValueType">int</span>.MaxValue);&#160; <br />} </div>  <p>Since I first wrote this post, I&#39;ve also added tests for empty sequences (where the first overload should throw an exception) and a test which relies on the first overload using the first element of the sequence as the seed, rather than the default value of the input sequence&#39;s element type.</p>  <p>Okay, enough about the testing... what about the real code?</p>  <h3>Let&#39;s implement it!</h3>  <p>I&#39;m still feeling my way around when it&#39;s a good idea to implement one method by using another, but at the moment my gut feeling is that it&#39;s okay to do so when:</p>  <ul>   <li>You&#39;re implementing one operator by reusing another overload of the same operator; in other words, no unexpected operators will end up in the stack trace of callers </li>    <li>There are no significant performance penalties for doing so </li>    <li>The observed behaviour is <em>exactly</em> the same - including argument validation </li>    <li>The code ends up being simpler to understand (obviously) </li> </ul>  <p>Contrary to an earlier version of this post, the first overload can&#39;t be implemented in terms of the second or third ones, because of its behaviour regarding the seed and empty sequences.</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource Aggregate&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TSource, TSource&gt; func)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (func == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;func&quot;</span>);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> InvalidOperationException(<span class="String">&quot;Source sequence was empty&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource current = iterator.Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (iterator.MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; current = func(current, iterator.Current);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> current;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>It still makes sense to share an implementation for the second and third overloads though. There&#39;s a choice around whether to implement the second operator in terms of the third (giving it an identity projection) or to implement the third operator in terms of the second (by just calling the second overload and then applying a projection). Obviously applying an unnecessary identity projection has a performance penalty in itself - but it&#39;s a <em>tiny</em> penalty. So which is more readable? I&#39;m in two minds about this. I like code where various methods call one other &quot;central&quot; method where <em>all</em> the real work occurs (suggesting implementing the second overload using the third) but equally I suspect I really think about aggregation in terms of getting the final value of the accumulator... with just a twist in the third overload, of an extra projection. I guess it depends on whether you think of the final projection as part of the general form or an &quot;extra&quot; step.</p>  <p>For the moment, I&#39;ve gone with the &quot;keep all logic in one place&quot; approach:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TAccumulate seed,     <br />&#160;&#160;&#160; Func&lt;TAccumulate, TSource, TAccumulate&gt; func)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.Aggregate(seed, func, x =&gt; x);     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TAccumulate seed,     <br />&#160;&#160;&#160; Func&lt;TAccumulate, TSource, TAccumulate&gt; func,     <br />&#160;&#160;&#160; Func&lt;TAccumulate, TResult&gt; resultSelector)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (func == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;func&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (resultSelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;resultSelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; TAccumulate current = seed;     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; current = func(current, item);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> resultSelector(current);     <br />} </div>  <p>The bulk of the &quot;real work&quot; method is argument validation - the actual iteration is almost painfully simple.</p>  <h3>Conclusion</h3>  <p>The moral of today&#39;s story is to read the documentation carefully - sometimes there&#39;s unexpected behaviour to implement. I still don&#39;t really know <em>why</em> this difference in behaviour exists... it feels to me as if the first overload really <em>should</em> behave like the second one, just with a default initial seed. EDIT: it seems that you need to read it <em>really</em> carefully. You know, every word of it. Otherwise you could make an embarrassing goof in a public blog post. &lt;sigh&gt;</p>  <p>The second moral should really be about the use of Aggregate - it&#39;s a <em>very</em> generalized operator, and you can implement any number of other operators (Sum, Max, Min, Average etc) using it. In some ways it&#39;s the scalar equivalent of SelectMany, just in terms of its diversity. Maybe I&#39;ll show some later operators implemented using Aggregate...</p>  <p>Next up, there have been requests for some of the set-based operators - Distinct, Union, etc - so I&#39;ll probably look at those soon.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
