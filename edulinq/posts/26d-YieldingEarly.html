<html>
<head>
<title>Reimplementing LINQ to Objects: Part 26d - Fixing the key selectors, and yielding early</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 26d - Fixing the key selectors, and yielding early</h1>
<p>I feel I need a voice over. &quot;Previously, on reimplementing LINQ to Objects...&quot; Well, we&#39;d got as far as a working implementation of OrderedEnumerable which didn&#39;t have terrible performance - <em>unless</em> you had an expensive key selector. Oh, and it didn&#39;t make use of the fact that we may only want the first few results.</p>  <h3>Executing key selectors only once</h3>  <p>Our first problem is to do with the key selectors. For various reasons (mentioned in <a href="http://msmvps.com/blogs/jon_skeet/archive/2011/01/05/reimplementing-linq-to-objects-part-26b-orderby-descending-thenby-descending.aspx">part 26b</a>) life is better if we execute the key selector once per input element. While we <em>can</em> do that with lazy evaluation, it makes more sense in my opinion to do it up-front. That means we need to separate out the key selector from the key comparer - in other words, we need to get rid of the handy ProjectionComparer we used to simplify the arguments to OrderBy/ThenBy/etc.</p>  <p>If we&#39;re going to keep the key selectors in a strongly typed way, that means our OrderedEnumerable (or at least <em>some</em> type involved in the whole business) needs to become generic in the key type. Let&#39;s bite the bullet and make it OrderedEnumerable. Now we have a slight problem right away in the fact that the &quot;CreateOrderedEnumerable&quot; method is generic, introducing a new type parameter TKey... so we shouldn&#39;t use TKey as the name of the new type parameter for OrderedEnumerable. We <em>could</em> rename the type parameter in the generic method implementation, but I&#39;m becoming a big believer in leaving the signatures of methods alone when I implement an interface. For type parameters it&#39;s not too bad, but for normal parameters it can be awful if you mess around with the names - particularly for those using named arguments.</p>  <p>Thinking ahead, our single &quot;key&quot; type parameter in OrderedEnumerable could well end up being a composite key. After all, if we have OrderBy(...).ThenBy(...).ThenBy(...) we&#39;re going to have to have some way of representing the key formed by the three selectors. It makes sense to use a &quot;nested&quot; key type, where the key type of OrderedEnumerable is always the &quot;composite key so far&quot;. Thus I named the type parameter TCompositeKey, and introduced an appropriate field. Here&#39;s the skeleton of the new class:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="ReferenceType">class</span> OrderedEnumerable&lt;TElement, TCompositeKey&gt; : IOrderedEnumerable&lt;TElement&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IEnumerable&lt;TElement&gt; source;     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> Func&lt;TElement, TCompositeKey&gt; compositeSelector;     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IComparer&lt;TCompositeKey&gt; compositeComparer;     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> OrderedEnumerable(IEnumerable&lt;TElement&gt; source,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Func&lt;TElement, TCompositeKey&gt; compositeSelector,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IComparer&lt;TCompositeKey&gt; compositeComparer)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.source = source;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.compositeSelector = compositeSelector;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.compositeComparer = compositeComparer;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Interface implementations here</span>     <br />} </div>  <p>(I&#39;m aware this is very &quot;stream of consciousness&quot; - I&#39;m assuming that presenting the decisions in the order in which I addressed them is a good way of explaining the necessary changes. Apologies if the style doesn&#39;t work for you.)</p>  <p>ThenBy and ThenByDescending don&#39;t have to change at all - they were already just using the interface. OrderBy and OrderByDescending become a little simpler, as we don&#39;t need to build the projection comparer. Here&#39;s the new version of OrderBy:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (keySelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;keySelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">new</span> OrderedEnumerable&lt;TSource, TKey&gt;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; (source, keySelector, comparer ?? Comparer&lt;TKey&gt;.Default);     <br />} </div>  <p>Lovely - we just call a constructor, basically.</p>  <p>So far, so good. Now what about the implementation of IOrderedEnumerable? We should expect this to get messy, because there are three types of key involved:</p>  <ul>   <li>The current key type </li>    <li>The secondary key type </li>    <li>The composite key type </li> </ul>  <p>Currently we don&#39;t even have a type which can represent the composite key. We <em>could</em> use something like <a href="http://msdn.microsoft.com/en-us/library/5tbh8a42.aspx">KeyValuePair&lt;TKey, TValue&gt;</a>, but that doesn&#39;t really give the right impression. Instead, let&#39;s create our own simple type:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="ValueType">struct</span> CompositeKey&lt;TPrimary, TSecondary&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> TPrimary primary;     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> TSecondary secondary;     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> TPrimary Primary { get { <span class="Statement">return</span> primary; } }     <br />&#160;&#160;&#160; <span class="Modifier">internal</span> TSecondary Secondary{ get { <span class="Statement">return</span> secondary; } }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> CompositeKey(TPrimary primary, TSecondary secondary)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.primary = primary;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.secondary = secondary;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Now we can easily create a projection from two key selectors to a new one which selects a composite key. However, we&#39;ll need to do the same thing for a comparer. We <em>could</em> use the CompoundComparer class we created before, but that will end up with quite a bit of indirection. Instead, it would be nice to have a type to work directly with CompositeKey - something which <em>knew</em> it was dealing with comparers of different types, one for each part of the key.</p>  <p>We could create a completely separate top-level type for that... but specifying the type parameters again seems a bit daft when we can reuse them by simply creating a nested class within CompositeKey:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="ValueType">struct</span> CompositeKey&lt;TPrimary, TSecondary&gt;     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Other members as shown above</span>     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span>&#160;<span class="Modifier">sealed</span>&#160;<span class="ReferenceType">class</span> Comparer : IComparer&lt;CompositeKey&lt;TPrimary, TSecondary&gt;&gt;     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IComparer&lt;TPrimary&gt; primaryComparer;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IComparer&lt;TSecondary&gt; secondaryComparer;     <br />    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Modifier">internal</span> Comparer(IComparer&lt;TPrimary&gt; primaryComparer,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; IComparer&lt;TSecondary&gt; secondaryComparer)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.primaryComparer = primaryComparer;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.secondaryComparer = secondaryComparer;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Modifier">public</span>&#160;<span class="ValueType">int</span> Compare(CompositeKey&lt;TPrimary, TSecondary&gt; x,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CompositeKey&lt;TPrimary, TSecondary&gt; y)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> primaryResult = primaryComparer.Compare(x.Primary, y.Primary);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (primaryResult != 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> primaryResult;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> secondaryComparer.Compare(x.Secondary, y.Secondary);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>This may look a little odd to begin with, but the two types really are quite deeply connected.</p>  <p>Now that we can compose keys in terms of both selection and comparison, we can implement CreateOrderedEnumerable:</p>  <div class="code"><span class="Modifier">public</span> IOrderedEnumerable&lt;TElement&gt; CreateOrderedEnumerable&lt;TKey&gt;(     <br />&#160;&#160;&#160; Func&lt;TElement, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer,     <br />&#160;&#160;&#160; <span class="ValueType">bool</span>&#160;<span class="Linq">descending</span>)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (keySelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;keySelector&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; comparer = comparer ?? Comparer&lt;TKey&gt;.Default;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (<span class="Linq">descending</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; comparer = <span class="Keyword">new</span> ReverseComparer&lt;TKey&gt;(comparer);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Copy to a local variable so we don&#39;t need to capture &quot;this&quot;</span>     <br />&#160;&#160;&#160; Func&lt;TElement, TCompositeKey&gt; primarySelector = compositeSelector;     <br />&#160;&#160;&#160; Func&lt;TElement, CompositeKey&lt;TCompositeKey, TKey&gt;&gt; newKeySelector =&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; element =&gt; <span class="Keyword">new</span> CompositeKey&lt;TCompositeKey, TKey&gt;(primarySelector(element), keySelector(element));     <br />    <br />&#160;&#160;&#160; IComparer&lt;CompositeKey&lt;TCompositeKey, TKey&gt;&gt; newKeyComparer =     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> CompositeKey&lt;TCompositeKey, TKey&gt;.Comparer(compositeComparer, comparer);     <br />    <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">new</span> OrderedEnumerable&lt;TElement, CompositeKey&lt;TCompositeKey, TKey&gt;&gt;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; (source, newKeySelector, newKeyComparer);     <br />} </div>  <p>I&#39;m not going to pretend that the second half of the method is anything other than ghastly. I&#39;m not sure I&#39;ve ever written code which is so dense in type arguments. IComparer&lt;CompositeKey&lt;TCompositeKey, TKey&gt;&gt; is a particularly &quot;fine&quot; type. Ick.</p>  <p>However, it works - and once you&#39;ve got your head round what each of the type parameters actually means at any one time, it&#39;s not really <em>complicated</em> code - it&#39;s just verbose and clunky.</p>  <p>The only bit which might require a bit of explanation is the primarySelector variable. I could certainly have just used compositeSelector within the lambda expression used to create the new key selector - it&#39;s not like it&#39;s going to change, after all. The memory benefits of not having a reference to &quot;this&quot; (where the intermediate OrderedEnumerable is likely to be eligible for GC collection immediately, in a typical OrderBy(...).ThenBy(...) call) are almost certainly not worth it. It just <em>feels right</em> to have both the primary and secondary key selectors in the same type, which is what will happen with the current code. They&#39;re both local variables, they&#39;ll be captured together, all will be well.</p>  <p>I hope you can see the parallel between the old code and the new code. Previously we composed a new (element-based) comparer based on the existing comparer, and a projection comparer from the method parameters. Now we&#39;re composing a new key selector and a new key comparer. It&#39;s all the same idea, just maintaining the split between key selection and key comparison.</p>  <h3>Now let&#39;s sort...</h3>  <p>So far, we haven&#39;t implemented GetEnumerator - and that&#39;s all. As soon as we&#39;ve done that to our satisfaction, we&#39;re finished with ordering.</p>  <p>There are <em>several</em> approaches to how we could sort. Here are a few of them:</p>  <ul>   <li>Project each element to its key, and create a KeyValuePair for each item. Merge sort in the existing way to achieve stability. This will involve copying a lot of data around - particularly if the element and key types end up being large value types. </li>    <li>Project each element to a { key, index } pair, and create another composite comparer which uses the index as a tie-breaker to achieve stability. This still involves copying keys around, but it means we could easily use a built-in sort (such as List&lt;T&gt;). </li>    <li>Project each element to a key, and separately create an array of indexes (0, 1, 2, 3...). Sort the <em>indexes</em> by accessing the relevant key at any point, using indexes as tie-breakers. This requires a more fiddly sort, as we need to keep indexing into the indexes array. </li>    <li>Build up &quot;chunks&quot; of sorted data as we read it in, keeping some number of chunks and merging them appropriate when we want to. We can then yield the results without ever performing a full sort, by effectively performing the &quot;merge&quot; operation of merge sort, just yielding values instead of copying them to temporary storage. (Obviously this is trivial with 2 chunks, but can be extended to more.) </li>    <li>Do something involving a self-balancing binary tree :) </li> </ul>  <p>I decided to pick the middle option, using <a href="http://en.wikipedia.org/wiki/Quicksort">quicksort</a> as the sorting algorithm. This comes with the normal problems of <em>possibly</em> picking bad pivots, but it&#39;s usually a reasonable choice. I believe there are cunning ways of improving the worst-case performance, but I haven&#39;t implemented any of those.</p>  <p>Here&#39;s the non-quicksort part of the code, just to set the scene.</p>  <div class="code"><span class="Modifier">public</span> IEnumerator&lt;TElement&gt; GetEnumerator()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// First copy the elements into an array: don&#39;t bother with a list, as we</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// want to use arrays for all the swapping around.</span>     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count;     <br />&#160;&#160;&#160; TElement[] data = source.ToBuffer(<span class="MethodParameter">out</span> count);     <br />    <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] indexes = <span class="Keyword">new</span>&#160;<span class="ValueType">int</span>[count];     <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = 0; i &lt; indexes.Length; i++)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; indexes[i] = i;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; TCompositeKey[] keys = <span class="Keyword">new</span> TCompositeKey[count];     <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = 0; i &lt; keys.Length; i++)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; keys[i] = compositeSelector(data[i]);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; QuickSort(indexes, keys, 0, count - 1);     <br />    <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = 0; i &lt; indexes.Length; i++)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> data[indexes[i]];     <br />&#160;&#160;&#160; }     <br />} </div>  <p>I could certainly have combined the first two loops - I just liked the separation provided in this code. One tiny micro-optimization point to note is that for each loop I&#39;m using the Length property of the array rather than &quot;count&quot; as the upper bound, as I believe that will reduce the amount of array boundary checking the JIT will generate. I very much doubt that it&#39;s relevant, admittedly :) I&#39;ve left the code here as it is in source control - but looking at it now, I could certainly have used a foreach loop on the final yield part. We wouldn&#39;t be able to later, admittedly... but I&#39;ll come to that all in good time.</p>  <p>The actual quicksort part is reasonably standard except for the fact that I pass in both the arrays for both indexes and keys - usually there&#39;s just the one array which is being sorted. Here&#39;s the code for both the recursive call and the partition part:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="ValueType">void</span> QuickSort(<span class="ValueType">int</span>[] indexes, TCompositeKey[] keys, <span class="ValueType">int</span> left, <span class="ValueType">int</span> right)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (right &gt; left)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> pivot = left + (right - left) / 2;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> pivotPosition = Partition(indexes, keys, left, right, pivot);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; QuickSort(indexes, keys, left, pivotPosition - 1);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; QuickSort(indexes, keys, pivotPosition + 1, right);     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="ValueType">int</span> Partition(<span class="ValueType">int</span>[] indexes, TCompositeKey[] keys, <span class="ValueType">int</span> left, <span class="ValueType">int</span> right, <span class="ValueType">int</span> pivot)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Remember the current index (into the keys/elements arrays) of the pivot location</span>     <br />&#160;&#160;&#160; <span class="ValueType">int</span> pivotIndex = indexes[pivot];     <br />&#160;&#160;&#160; TCompositeKey pivotKey = keys[pivotIndex];     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Swap the pivot value to the end</span>     <br />&#160;&#160;&#160; indexes[pivot] = indexes[right];     <br />&#160;&#160;&#160; indexes[right] = pivotIndex;     <br />&#160;&#160;&#160; <span class="ValueType">int</span> storeIndex = left;     <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = left; i &lt; right; i++)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> candidateIndex = indexes[i];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TCompositeKey candidateKey = keys[candidateIndex];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> comparison = compositeComparer.Compare(candidateKey, pivotKey);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (comparison &lt; 0 || (comparison == 0 &amp;&amp; candidateIndex &lt; pivotIndex))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Swap storeIndex with the current location</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; indexes[i] = indexes[storeIndex];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; indexes[storeIndex] = candidateIndex;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; storeIndex++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="InlineComment">// Move the pivot to its final place</span>     <br />&#160;&#160;&#160; <span class="ValueType">int</span> tmp = indexes[storeIndex];     <br />&#160;&#160;&#160; indexes[storeIndex] = indexes[right];     <br />&#160;&#160;&#160; indexes[right] = tmp;     <br />&#160;&#160;&#160; <span class="Statement">return</span> storeIndex;     <br />} </div>  <p>It&#39;s interesting to observe how similar the quicksort and merge sort recursive parts are - both picking a midpoint, recursing on the left of it, recursing on the right of it, and performing some operation on the whole sublist. Of course the &quot;some operation&quot; is very different between partition and merge, and it occurs at a different time - but it&#39;s an interesting parallel nonetheless.</p>  <p>One significant difference between merge sort and quicksort is the use of the pivot. Once Partition has returned where the pivot element ended up, quicksort doesn&#39;t touch that element itself (we already know it will be in the right place). It recurses on the sublist entirely to the left of the pivot and the sublist entirely to the right of the pivot. Compare this with merge sort with recurses on two sublists which together comprise the whole list for that call.</p>  <p>The overloading of the word &quot;index&quot; here is unfortunate, but that is unfortunately life. Both sorts of &quot;index&quot; here really are indexes... you just need to keep an eye on which is which.</p>  <p>The final point to note is how we&#39;re using the indexes in the comparison, as a tie-break to keep stability. It&#39;s an ugly expression, but it does the job.</p>  <p>(As a small matter of language, I wasn&#39;t sure whether to use indexes or indices. I far prefer the former, so I used it. Having just checked in the dictionary, it appears both are correct. This reminds me of when I was writing C# in Depth - I could never decide between appendixes and appendices. Blech.)</p>  <p>Now, do you want to hear the biggest surprise I received last night? After I&#39;d fixed up the compile-time errors to arrive at the code above, <em>it worked first time</em>. I&#39;m not kidding. I&#39;m not quite sure how I pulled that off (merge sort didn&#39;t take long either, but it did at least have a few tweaks to fix up) but it shocked the heck out of me. So, are we done? Well, not quite.</p>  <h3>Yielding early</h3>  <p>Just as a reminder, one of my aims was to be able to use iterator blocks to return some values to anyone iterating over the result stream without having to do <em>all</em> the sorting work. This means that in the case of calling OrderBy(...).Take(5) on a large collection, we can end up saving a lot of work... I hope!</p>  <p>This is currently fairly normal quicksort code, leaving the &quot;dual arrays&quot; aspect aside... but it&#39;s not quite amenable to early yielding. We&#39;re definitely <em>computing</em> the earliest results first, due to the order of the recursion - but we can&#39;t yield from the recursive method - iterator blocks just don&#39;t do that.</p>  <p>So, we&#39;ll have to fake the recursion. Fortunately, quicksort is only <em>directly</em> recursive - we don&#39;t need to worry about mutually recursive routines: A calling B which might call C or it might call back to A, etc. Instead, we can just keep a Stack&lt;T&gt; of &quot;calls&quot; to quicksort that we want to make, and execute the appropriate code within our GetEnumerator() method, so we can yield at the right point. Now in the original code, quicksort has four parameters, so you might expect our Stack&lt;T&gt; to have those four values within T too... but no! Two of those values are just the keys and indexes... and we already have those in two local variables. We only need to keep track of &quot;right&quot; and &quot;left&quot;. Again, for the sake of clarity I decided to implement this using a custom struct - nested within OrderedEnumerable as there&#39;s no need for it to exist anywhere else:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="ValueType">struct</span> LeftRight     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">internal</span>&#160;<span class="ValueType">int</span> left, right;     <br />&#160;&#160;&#160; <span class="Modifier">internal</span> LeftRight(<span class="ValueType">int</span> left, <span class="ValueType">int</span> right)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.left = left;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.right = right;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Purists amongst you may curse at the use of internal fields rather than properties. I&#39;m not bothered - this is a private class, and we&#39;re basically using this as a tuple. Heck, I would have used anonymous types if it weren&#39;t for two issues:</p>  <ul>   <li>I wanted to use Stack&lt;T&gt;, and there&#39;s no way of creating one of those for an anonymous type (without introducing more generic methods to use type inference) </li>    <li>I wanted to use a struct - we&#39;ll end up creating a lot of these values, and there&#39;s simply no sense in them being individual objects on the heap. Anonymous types are always classes. </li> </ul>  <p>So, as a first step we can transform our code to use this &quot;fake recursion&quot; but still yield at the very end:</p>  <div class="code"><span class="Linq">var</span> stack = <span class="Keyword">new</span> Stack&lt;LeftRight&gt;();     <br />stack.Push(<span class="Keyword">new</span> LeftRight(0, count - 1));     <br /><span class="Statement">while</span> (stack.Count &gt; 0)     <br />{     <br />&#160;&#160;&#160; LeftRight leftRight = stack.Pop();     <br />&#160;&#160;&#160; <span class="ValueType">int</span> left = leftRight.left;     <br />&#160;&#160;&#160; <span class="ValueType">int</span> right = leftRight.right;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (right &gt; left)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> pivot = left + (right - left) / 2;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> pivotPosition = Partition(indexes, keys, left, right, pivot);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; stack.Push(<span class="Keyword">new</span> LeftRight(pivotPosition + 1, right));     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; stack.Push(<span class="Keyword">new</span> LeftRight(left, pivotPosition - 1));     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Statement">for</span> (<span class="ValueType">int</span> i = 0; i &lt; indexes.Length; i++)&#160; <br />{&#160; <br />&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> data[indexes[i]];&#160; <br />} </div>  <p>We initially push a value of (0, count - 1) to simulate the call to QuickSort(0, count - 1) which started it all before. The code within the loop is very similar to the original QuickSort method, with three changes:</p>  <ul>   <li>We have to grab the next value of LeftRight from the stack, and then separate it into left and right values </li>    <li>Instead of calls to QuickSort, we have calls to stack.Push </li>    <li>We&#39;ve reversed the order of the recursive calls: in order to sort the left sublist <em>first</em>, we have to push it onto the stack <em>last</em>. </li> </ul>  <p>Happy so far? We&#39;re getting very close now. All we need to do is work out when to yield. This is the bit which caused me the most headaches, until I worked out that the &quot;if (right &gt; left)&quot; condition really meant &quot;if we&#39;ve got work to do&quot;... and we&#39;re interested in the exact opposite scenario - when we <em>don&#39;t</em> have any work to do, as that means everything up to and including &quot;right&quot; is already sorted. There are two situations here: either right == left, i.e. we&#39;re sorting one element, or right == left - 1, which will occur if we picked a pivot which was the maximum or minimum value in the list at the previous recursive step.</p>  <p>It&#39;s taken me a little bit of thinking (and just running the code) to persuade me that we will <em>always </em>naturally reach a situation where we end up seeing right == count and right &lt;= left, i.e. a place where we know we&#39;re completely done. But it&#39;s okay - it does happen.</p>  <p>It&#39;s not just a case of yielding the values between left and right though - because otherwise we&#39;d never yield a pivot. Remember how I pointed out that quick sort missed out the pivot when specifying the sublists to recurse into? Well, that&#39;s relevant here. Fortunately, it&#39;s really easy to work out what to do. Knowing that everything up to and including &quot;right&quot; has been sorted means we just need to keep a cursor representing the next index to yield, and then just move that cursor up until it&#39;s positioned beyond &quot;right&quot;. The code is probably easier to understand than the description:</p>  <div class="code"><span class="ValueType">int</span> nextYield = 0;     <br />    <br /><span class="Linq">var</span> stack = <span class="Keyword">new</span> Stack&lt;LeftRight&gt;();     <br />stack.Push(<span class="Keyword">new</span> LeftRight(0, count - 1));     <br /><span class="Statement">while</span> (stack.Count &gt; 0)     <br />{     <br />&#160;&#160;&#160; LeftRight leftRight = stack.Pop();     <br />&#160;&#160;&#160; <span class="ValueType">int</span> left = leftRight.left;     <br />&#160;&#160;&#160; <span class="ValueType">int</span> right = leftRight.right;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (right &gt; left)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> pivot = left + (right - left) / 2;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> pivotPosition = Partition(indexes, keys, left, right, pivot);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Push the right sublist first, so that we *pop* the</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// left sublist first</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; stack.Push(<span class="Keyword">new</span> LeftRight(pivotPosition + 1, right));     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; stack.Push(<span class="Keyword">new</span> LeftRight(left, pivotPosition - 1));     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">else</span>     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">while</span> (nextYield &lt;= right)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> data[indexes[nextYield]];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; nextYield++;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Tada! It works (at least according to my tests).</p>  <p>I <em>have</em> tried optimizing this a little further, to deal with the case when right == left + 1, i.e. we&#39;re only sorting two elements. It feels like that <em>ought</em> to be cheaper to do explicitly than via pivoting and adding two pointless entries to the stack... but the code gets a <em>lot</em> more complicated (to the point where I had to fiddle significantly to get it working) and from what I&#39;ve seen, it doesn&#39;t make much performance difference. Odd. If this were a production-quality library to be used in performance-critical situations I&#39;d go further in the testing, but as it is, I&#39;m happy to declare victory at this point.</p>  <h3>Performance</h3>  <p>So, how well does it perform? I&#39;ve only performed crude tests, and they perplex me somewhat. I&#39;m sure that last night, when I was running the &quot;yield at the end&quot; code, my tests were running twice as slowly in Edulinq as in LINQ to Objects. Fair enough - this is just a hobby, Microsoft have no doubt put a lot of performance testing effort into this. (That hasn&#39;t stopped them from <a href="https://connect.microsoft.com/VisualStudio/feedback/details/634949">messing up &quot;descending&quot; comparers</a>, admittedly, as I found out last night to my amusement.) That was on my &quot;meaty&quot; laptop (which is 64-bit with a quad core i7). On my netbook this morning, the same Edulinq code seemed to be running slightly faster than LINQ to Objects. Odd.</p>  <p>This evening, having pulled the &quot;early out&quot; code from the source repository, the Edulinq implementation is running faster than the LINQ to Objects implementation even when the &quot;early out&quot; isn&#39;t actually doing much good. That&#39;s just plain weird. I blame my benchmarking methodology, which is far from rigorous. I&#39;ve tweaked the <em>parameters</em> of my tests quite a bit, but I haven&#39;t tried all kinds of different key and element types, etc. The basic results are very roughly:</p>  <ul>   <li>When evaluating the whole ordered list, Edulinq appears to run about 10% faster than LINQ to Objects </li>    <li>When evaluating only the top 5 of a large ordered list, Edulinq can be <em>much</em> faster. How much faster depends on the size of the list of course, and it still has to perform the initial complete partitioning step - but on 100,000 items it&#39;s regularly about 10x faster than LINQ to Objects. </li> </ul>  <p>That makes me happy :) Of course, the code is all open source, so if Microsoft wish to include the Edulinq implementation in .NET 5, they&#39;re quite at liberty to do so, as long as they abide by the terms of the licence. I&#39;m not holding my breath ;)</p>  <p>More seriously, I fully expect there are a bunch of scenarios where my knocked-up-in-an-evening code performs slower than that in the framework. Maybe my approach takes a lot more memory. Maybe it has worse locality of reference in some scenarios. There are all kinds of possibilities here. Full performance analysis was never meant to be the goal of Edulinq. I&#39;m doing this in the spirit of learning more about LINQ - but it&#39;s fun to try to optimize just a <em>little</em> bit. I&#39;m going to delete the increasingly-inaccurately-named MergeSortTest project now - I may institute a few more benchmarks later on though. I&#39;m also removing CompoundComparer and ProjectionComparer, which are no longer used. They&#39;ll live on in part 26a though...</p>  <h3>Conclusions</h3>  <p>Well that was fun, wasn&#39;t it? I&#39;m pretty pleased with the result. The final code has some nasty generic complexity in it, but it&#39;s not too bad if you keep all the types clear in your mind.</p>  <p>None of the remaining operators will be nearly as complex as this, unless I choose to implement AsQueryable (which I wasn&#39;t planning on doing). On the other hand, as I&#39;ve mentioned before, Max/Sum/etc have <em>oodles</em> of overloads. While I&#39;ll certainly implement all of them, I&#39;m sure I&#39;ll only present the <em>code</em> for selected interesting overloads.</p>  <p>As a bit of light relief, I think I&#39;ll tackle Reverse. That&#39;s about as simple as it gets - although it could still present some interesting options.</p>  <h3>Addendum</h3>  <p>An earlier version of this post (and the merge sort implementation) had a flawed piece of code for choosing the pivot. Here&#39;s both the old and the new code:</p>  <div class="code"><span class="InlineComment">// Old code</span>    <br /><span class="ValueType">int</span> pivot = (left + right) / 2;    <br />    <br /><span class="InlineComment">// New code</span>    <br /><span class="ValueType">int</span> pivot = left + (right - left) / 2; </div>  <p>The difference is whether or not the code can overflow when left and right are very large. Josh Bloch <a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">wrote about it back in 2006</a>. A colleague alerted me to this problem shortly after posting, but it&#39;s taken until now to correct it. (I fixed the source repository almost immediately, but deferred writing this addendum.) Why was I not too worried? Because .NET restricts each object to be less than 2GB in size, even in .NET 4.0, even on a 64-bit CLR. As we&#39;ve created an array of integers, one per entry, that means we can only have just under (int.MaxValue / 4) elements. Within those limits, there&#39;s no problem in the original pivot code. However, it&#39;s still worth fixing of course - one never knows when the restriction will be lifted. The CLR team blogged about the issue <a href="http://blogs.msdn.com/b/joshwil/archive/2005/08/10/450202.aspx">back in 2005</a> (when the 64-bit CLR was new) - I haven&#39;t seen any mentions of plans to remove the limitation, but I would imagine it&#39;s discussed periodically.</p>  <p>One oddity about this is that the Array class itself has some API support for large arrays, such as the <a href="http://msdn.microsoft.com/en-us/library/system.array.longlength.aspx">LongLength property</a>. To be honest, I can&#39;t see large arrays ever being particularly pleasant to work with - what would they return for the normal Length property, for example, or their implementation of IList&lt;T&gt; etc? I suspect we may see support for larger objects before we see support for arrays with more than int.MaxValue elements, but that&#39;s a complete guess.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
