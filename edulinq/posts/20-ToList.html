<html>
<head>
<title>Reimplementing LINQ to Objects: Part 20 - ToList</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 20 - ToList</h1>
<p>This morning I started writing the tests for GroupBy, prior to implementing it. That turned out to be a pain - really I wanted an easy way of getting at each element of the result (i.e. each result group). If only I had the ability to convert an arbitrary sequence into a query... I needed ToList. So, we enter a fairly brief diversion.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb342261.aspx" target="_blank">ToList</a> has a single, simple overload:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> List&lt;TSource&gt; ToList&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source) </div>  <p>Fairly obviously, ToList converts the source sequence into a list. Some points to note:</p>  <ul>   <li>The signature specifies List&lt;T&gt;, not just IList&lt;T&gt;. Of course it could return a subclass of List&lt;T&gt;, but there seems little point. </li>    <li>It uses <em>immediate execution</em> - nothing is deferred here </li>    <li>The parameter (source) musn&#39;t be null </li>    <li>It&#39;s optimized for the case when source implements ICollection&lt;T&gt; </li>    <li>It <em>always</em> creates a new, independent list. </li> </ul>  <p>The last two points are worth a bit more discussion. Firstly, the optimization for ICollection&lt;T&gt; isn&#39;t documented, but it makes a lot of sense:</p>  <ul>   <li>List&lt;T&gt; stores its data in an array internally </li>    <li>ICollection&lt;T&gt; exposes a Count property so the List&lt;T&gt; can create an array of exactly the right size to start with </li>    <li>ICollection&lt;T&gt; exposes a CopyTo method so that the List&lt;T&gt; can copy all the elements into the newly created array in bulk </li> </ul>  <p>ToList always creates a new list for consistency. If it just returned the source parameter directly if it was already a List&lt;T&gt;, that would mean that changes to the source after calling ToList would <em>sometimes</em> be visible in the returned list and sometimes not... making it harder to reason about any code which used ToList.</p>  <h3>What are we going to test?</h3>  <p>I have tests for the bullet points listed above, and one extra test just to prove that it can work with lazily evaluated sequences as well as simple collections like arrays. (The test uses a range followed by a projection.)</p>  <p>In order to test the optimization for ICollection&lt;T&gt;, I&#39;ve implemented another collection like NonEnumerableList, but this time just NonEnumerableCollection. Again, this just delegates all ICollection&lt;T&gt; operations to a backing List&lt;T&gt;, but throws an exception if you try to call GetEnumerator(). The test then just calls ToList on a NonEnumerableCollection: as no exception is thrown, that proves that either the operation is optimized as we&#39;d expect, or the exception is being swallowed. I think it&#39;s reasonable to assume that exceptions aren&#39;t swallowed in LINQ to Objects :)</p>  <h3>Let&#39;s implement it!</h3>  <p>This will probably be the simplest implementation in the whole of Edulinq:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> List&lt;TSource&gt; ToList&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">new</span> List&lt;TSource&gt;(source);     <br />} </div>  <p>You may well be wondering what happened to the optimization... well, it&#39;s in the List&lt;T&gt; constructor. We just get it for free. Unfortunately <em>that&#39;s</em> not documented either... so we end up with an implementation which implements one undocumented optimization if List&lt;T&gt; implements another undocumented optimization :)</p>  <p>We can&#39;t actually do much better than that - we can&#39;t use ICollection&lt;T&gt;.CopyTo ourselves, as we don&#39;t have access to the underlying array of List&lt;T&gt;. We could perform <em>some</em> optimization by calling the List&lt;T&gt; constructor which specifies a capacity, and then call AddRange. That would at least prevent the list from having to resize itself, but it would still need to iterate over the whole collection instead of using the (potentially very fast) CopyTo method.</p>  <h3>Conclusion</h3>  <p>You may be wondering why we even need ToList, if we could just create a list by calling the constructor directly. The difference is that in order to call a constructor, you need to specify the element type as the type argument. When we use ToList, we can take advantage of type inference. In many cases this is just extremely convenient, but for anonymous types it&#39;s actually required. How can you end up with a strongly typed list of an anonymous type? It&#39;s easy with ToList, like this:</p>  <div class="code"><span class="Linq">var</span> query = Enumerable.Range(0, 10)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(x =&gt; <span class="Keyword">new</span> { Value = x, Doubled = x * 2 });    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="Linq">var</span> list = query.ToList(); </div>  <p>Try doing that without an extension method or something similar. It&#39;s worth noting at this point that although there are similar methods for arrays and Dictionary, there&#39;s no equivalent for HashSet. It&#39;s incredibly easy to write, of course, and an obvious extension to LINQ to Objects - but it&#39;s not in the standard library. Maybe for .NET 5...</p>  <p>So, now that we&#39;ve got ToList sorted, I can get back to GroupBy and its eight overloads - easy to implement, but hard to test simply and hard to describe clearly. Lucky me.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
