<html>
<head>
<title>Reimplementing LINQ to Objects: Part 38 - What's missing?</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 38 - What's missing?</h1>
<p>I mentioned before that the Zip operator was only introduced in .NET 4, so clearly there&#39;s a <em>little</em> wiggle room for LINQ to Object&#39;s query operators to grow in number. This post mentions some of the ones I think are most sorely lack - either because I&#39;ve wanted them myself, or because I&#39;ve seen folks on Stack Overflow want them for entirely reasonable use cases.</p>  <p>There is an issue with respect to other LINQ providers, of course: as soon as some useful operators are available for LINQ to Objects, there will be people who want to apply them to LINQ to SQL, the Entity Framework and the like. Worse, if they&#39;re <em>not</em> included in Queryable with overloads based on expression trees, the LINQ to Objects implementation will silently get picked - leading to what looks like a lovely query performing like treacle while the client slurps over the entire database. If they <em>are</em> included in Queryable, then third party LINQ providers could end up with a nasty versioning problem. In other words, some care is needed and I&#39;m glad I&#39;m not the one who has to decide how new features are introduced.</p>  <p>I&#39;ve deliberately <em>not</em> looked at the extra set of operators introduced in the System.Interactive part of <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896">Reactive Extensions</a>... nor have I looked back over what we&#39;ve implemented in <a href="http://morelinq.googlecode.com/">MoreLINQ</a> (an open source project I started specifically to create new operators). I figured it would be worth thinking about this afresh - but look at both of those projects for actual implementations instead of just ideas.</p>  <p>Currently there&#39;s no implementation of any of this in Edulinq - but I could potentially create an &quot;Edulinq.Extras&quot; assembly which made it all available. Let me know if any of these sounds particularly interesting to see in terms of implementation.</p>  <h3>FooBy</h3>  <p>I <em>love</em> OrderBy and ThenBy, with their descending cousins. They&#39;re so much cleaner than building a custom comparer which just performs a comparison between two properties. So why stop with ordering? There&#39;s a whole bunch of operators which could do with some &quot;FooBy&quot; love. For example, imagine we have a list of files, and we want to find the longest one. We don&#39;t want to perform a total ordering by size descending, nor do we want to find the maximum file size itself: we want the file <em>with</em> the maximum size. I&#39;d like to be able to write that query as:</p>  <div class="code">FileInfo biggestFile = files.MaxBy(file =&gt; file.Length); </div>  <p>Note that we can get a <em>similar</em> result by performing one pass to find the maximum length, and then another pass to find the file with that length. However, that&#39;s inefficient and assumes we can read the sequence twice (and get the same results both times). There&#39;s no need for that. We could get the same result using Aggregate with a pretty complicated aggregation, but I think this is a sufficiently common case to deserve its own operator.</p>  <p>We&#39;d want to specify which value would be returned if multiple files had the same length (my suggestion would be the first one we encountered with that length) and we could also specify a key comparer to use. The signatures would look like this:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource MaxBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource MaxBy&lt;TSource, TKey&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TKey&gt; keySelector,     <br />&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer) </div>  <p>Now it&#39;s not just Max and Min that gain from this &quot;By&quot; idea. It would be useful to apply the same idea to the set operators. The simplest of these to think about would be DistinctBy, but UnionBy, IntersectBy and ExceptBy would be reasonable too. In the case of ExceptBy and IntersectBy we <em>could</em> potentially take the key collection to indicate the keys of the elements we wanted to exclude/include, but it would probably be more consistent to force the two input sequences to be of the same type (as they would have to be for UnionBy and IntersectBy of course). ContainsBy <em>might</em> be useful, but that would effectively be a Select followed by a normal Contains - possibly not useful enough to merit its own operator.</p>  <h3>TopBy and TopByDescending</h3>  <p>These may sound like they belong in the FooBy section, but they&#39;re somewhat different: they&#39;re effectively specializations of OrderBy and OrderByDescending where you already know how many elements you want to preserve. The return type would be IOrderedEnumerable&lt;T&gt; so you could still use ThenBy/ThenByDescending as normal. That would make the following two queries equivalent - but the second <em>might</em> be a lot more efficient than the first:</p>  <div class="code"><span class="Linq">var</span> takeQuery = people.OrderBy(p =&gt; p.LastName)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .ThenBy(p =&gt; p.FirstName)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Take(3);     <br />    <br /><span class="Linq">var</span> topQuery = people.TopBy(p =&gt; p.LastName, 3)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .ThenBy(p =&gt; p.FirstName); </div>  <p>An implementation could easily delegate to various different strategies depending on the number given - for example, if you asked for more than 10 values, it may not be worth doing anything more than a simple sort and restrict the output. If you asked for just the top 3 values, that could return an IOrderedEnumerable implementation specifically hard-coded to 3 values, etc.</p>  <p>Aside from anything else, if you were confident in what the implementation did (and that&#39;s a <em>very</em> big &quot;if&quot;) you could use a potentially huge input sequence with such a query - larger than you could fit into memory in one go. That&#39;s fine if you&#39;re only keeping the top three values you&#39;ve seen so far, but would fail for a complete ordering, even one which was able to yield results before performing <em>all</em> the ordering: if it doesn&#39;t <em>know</em> you&#39;re going to stop after three elements, it can&#39;t throw anything away.</p>  <p>Perhaps this is too specialized an operator - but it&#39;s an interesting one to think about. It&#39;s worth noting that this probably only makes sense for LINQ to Objects, which never gets to see the whole query in one go. Providers like LINQ to SQL can optimize queries of the form OrderBy(...).ThenBy(...).Take(...) because by the time they need to translate the query into SQL, they will have an expression tree representation which includes the &quot;Take&quot; part.</p>  <h3>TryFastCount and TryFastElementAt</h3>  <p>One of the implementation details of Edulinq is its TryFastCount method, which basically encapsulates the logic around attempting to find the count of a sequence if it implements ICollection or ICollection&lt;T&gt;. Various built-in LINQ operators find this useful, and anyone writing their own operators has a reasonable chance of bumping into it as well. It seems pointless to duplicate the code all over the place... why not expose it? The signatures might look something like this:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> TryFastCount&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="MethodParameter">out</span>&#160;<span class="ValueType">int</span> count)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> TryFastElementAt&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> index,     <br />&#160;&#160;&#160; <span class="MethodParameter">out</span> TSource value) </div>  <p>I would expect TryFastElementAt to use the indexer if the sequence implemented IList&lt;T&gt; without performing any validation: that ought to be the responsibility of the caller. TryFastCount could use a Nullable&lt;int&gt; return type instead of the return value / out parameter split, but I&#39;ve kept it consistent with the methods which exist elsewhere in the framework</p>  <h3>Scan and SelectAdjacent</h3>  <p>These are related operators in that they deal with wanting a more global view than just the current element. Scan would act similarly to Aggregate - except that it would yield the accumulator value after each element. Here&#39;s an example of keeping a running total:</p>  <div class="code"><span class="InlineComment">// Signature:</span>     <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TAccumulate&gt; Scan&lt;TSource, TAccumulate&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; TAccumulate seed,     <br />&#160;&#160;&#160; Func&lt;TAccumulate, TSource, TAccumulate&gt; func)     <br />&#160;&#160;&#160;&#160; <br />    <br /><span class="ValueType">int</span>[] source = <span class="Keyword">new</span>&#160;<span class="ValueType">int</span>[] { 3, 5, 2, 1, 4 };     <br /><span class="Linq">var</span> query = source.Scan(0, (current, item) =&gt; current + item);     <br />query.AssertSequenceEqual(3, 8, 10, 11, 15); </div>  <p>There <em>could</em> be a more complicated overload with an extra conversion from TAccumulate to an extra TResult type parameter. That would let us write a Fibonacci sequence query in one line, if we really wanted to...</p>  <p>The SelectAdjacent operator would simply present a selector function with pairs of adjacent items. Here&#39;s a similar example, this time calculating the difference between each pair:</p>  <div class="code"><span class="InlineComment">// Signature:</span>     <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; SelectAdjacent&lt;TSource, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, TSource, TResult&gt; selector)     <br />&#160;&#160;&#160;&#160; <br />    <br /><span class="ValueType">int</span>[] source = <span class="Keyword">new</span>&#160;<span class="ValueType">int</span>[] { 3, 5, 2, 1, 4 };     <br /><span class="Linq">var</span> query = source.SelectAdjacent((current, next) =&gt; next - current);     <br />query.AssertSequenceEqual(2, -3, -1, 3); </div>  <p>One oddity here is that the result sequence always contains one item fewer than the source sequence. If we wanted to keep the length the same, there are various approaches we could take - but the best one would depend on the situation.</p>  <p>This sounds like a pretty obscure operator, but I&#39;ve actually seen quite a few LINQ questions on Stack Overflow where it could have been useful. Is it useful often <em>enough</em> to deserve its own operator? Maybe... maybe not.</p>  <h3>DelimitWith</h3>  <p>This one is really just a bit of a peeve - but again, it&#39;s a pretty common requirement. We often want to take a sequence and create a single string which is (say) a comma-delimited version. Yay, String.Join does exactly what we need - particularly in .NET 4, where there&#39;s an <a href="http://msdn.microsoft.com/en-us/library/dd992421.aspx">overload taking IEnumerable&lt;T&gt;</a> so you don&#39;t need to convert it to a string array first. However, it&#39;s still a <em>static</em> method on string - and the name &quot;Join&quot; also looks slightly odd in the context of a LINQ query, as it&#39;s got nothing to do with a LINQ-style join.</p>  <p>Compare these two queries: which do you think reads better, and feels more &quot;natural&quot; in LINQ?</p>  <div class="code"><span class="InlineComment">// Current state of play...</span>     <br /><span class="Linq">var</span> names = <span class="ReferenceType">string</span>.Join(<span class="String">&quot;,&quot;</span>,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; people.Where(p =&gt; p.Age &lt; 18)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(p =&gt; p.FirstName));     <br />    <br /><span class="InlineComment">// Using DelimitWith</span>     <br /><span class="Linq">var</span> names = people.Where(p =&gt; p.Age &lt; 18)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(p =&gt; p.FirstName)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .DelimitWith(<span class="String">&quot;,&quot;</span>); </div>  <p>I know which I prefer :)</p>  <h3>ToHashSet</h3>  <p>(Added on February 23rd 2011.)</p>  <p>I&#39;m surprised I missed this one first time round - I&#39;ve bemoaned its omission in various places before now. It&#39;s easy to create a list, dictionary, lookup or array from an anonymous type, but you can&#39;t create a set that way. That&#39;s mad, given how simple the relevant operator is, even with an overload for a custom equality comparer:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">return</span> source.ToHashSet(EqualityComparer&lt;TSource&gt;.Default);    <br />}    <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt;(    <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,    <br />&#160;&#160;&#160; IEqualityComparer&lt;TSource&gt; comparer)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(&quot;source&quot;);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">new</span> HashSet&lt;TSource&gt;(source, comparer ?? EqualityComparer&lt;TSource&gt;.Default);    <br />} </div>  <p>This also makes it much simpler to create a HashSet in a readable way from an existing query expression, without either wrapping the whole query in the constructor call or using a local variable.</p>  <h3>Conclusion</h3>  <p>These are just the most useful extra methods I thought of, based on the kinds of query folks on Stack Overflow have asked about. I think it&#39;s interesting that some are quite general - MaxBy, ExceptBy, Scan and so on - whereas others (TopBy, SelectAdjacent and particularly DelimitWith) are simply aimed at making some very specific but common situations simpler. It feels to me like the more general operators really are <em>missing</em> from LINQ - they would fit quite naturally - but the more specific ones probably deserve to be in a separate static class, as &quot;extras&quot;.</p>  <p>This is only scratching the surface of what&#39;s possible, of course - System.Interactive.EnumerableEx in Reactive Extensions has <em>loads</em> of options. Some of them are deliberate parallels of the operators in Observable, but plenty make sense on their own too.</p>  <p>One operator you may have <em>expected</em> to see in this list is ForEach. This is a controversial topic, but Eric Lippert <a href="http://blogs.msdn.com/b/ericlippert/archive/2009/05/18/foreach-vs-foreach.aspx">has written about it very clearly</a> (no surprise there, then). Fundamentally LINQ is about <em>querying</em> a sequence, not taking <em>action</em> on it. ForEach breaks that philosophy, which is why I haven&#39;t included it here. Usually a foreach statement is a perfectly good alternative, and make the &quot;action&quot; aspect clearer.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
