<html>
<head>
<title>Reimplementing LINQ to Objects: Part 26a - IOrderedEnumerable</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 26a - IOrderedEnumerable</h1>
<p>Implementing OrderBy/OrderByDescending/ThenBy/ThenByDescending isn&#39;t too bad, once you understand how the pattern works, but that&#39;s a slight conceptual leap. I&#39;ll take it one step at a time, first introducing some extra infrastructure (both public and internal), then implementing it simply and slowly, and finally optimizing it somewhat.</p>  <h3>The sorting features of LINQ</h3>  <p>As a query language, it&#39;s natural that LINQ allows you to sort sequences. Of course, collections have had the ability to sort their contents <a href="http://msdn.microsoft.com/en-us/library/8k6e334t.aspx">since v1.0</a> but LINQ is different in various ways:</p>  <ul>   <li>It expects you&#39;ll usually want to sort via projections, rather than on a &quot;natural&quot; comparison of the whole value. For example, should I come before or after my wife in a sorted list of people? It depends on whether you&#39;re ordering by first name, age, height, weight, or something else. </li>    <li>It allows you to <em>easily</em> specify whether you want the ordering to be from the minimum value to the maximum (ascending) or from maximum to minimum (descending). </li>    <li>It allows you to specify multiple ordering criteria - for example, order by last name and then first name. </li>    <li>It doesn&#39;t sort in-place - instead, the sorting operators each return a new sequence which represents the results of the sort. </li>    <li>It allows you to order <em>any</em> sequence implementing IEnumerable&lt;T&gt; - rather than Array.Sort being separate from List&lt;T&gt;.Sort, for example. </li>    <li>The ordering operators in LINQ to Objects at least are <em>stable</em> - two equal items will be returned in the original order. </li> </ul>  <p>Other than stability (I&#39;m at least unaware of any public, stable sort methods within the framework prior to .NET 3.5), all of this <em>can</em> be done using IComparer&lt;T&gt;, but it&#39;s a bit of a pain. Just as a reminder, <a href="http://msdn.microsoft.com/en-us/library/8ehhxeaf.aspx">IComparer&lt;T&gt;</a> is an interface with a single method:</p>  <div class="code"><span class="ValueType">int</span> Compare(T x, T y) </div>  <p>Unlike IEqualityComparer&lt;T&gt;, an IComparer&lt;T&gt; can <em>only</em> be asked to compare two items to determine which should come before the other in an ordered sequence. There&#39;s no notion of a hash code in IComparer&lt;T&gt;. All sorting in .NET is based on either IComparer&lt;T&gt; or <a href="http://msdn.microsoft.com/en-us/library/tfakywbh.aspx">Comparison&lt;T&gt;</a>, which is the equivalent delegate. Like IEqualityComparer&lt;T&gt;, a helper class (Comparer&lt;T&gt;) exists mostly to provide a default comparison based on the IComparable&lt;T&gt; and IComparable interfaces. (Unlike EqualityComparer&lt;T&gt;.Default, there&#39;s no &quot;fall back&quot; to a <em>universal</em> default comparison - if you try to compare two objects which have no comparison defined between them, an exception will be thrown.)</p>  <h3>Composing comparers</h3>  <p>Eventually, we&#39;ll need our ordering implementation to be built on top of IComparer&lt;T&gt;, so I&#39;ll introduce three helper classes to address the first three bullet points above. <a href="http://pobox.com/~skeet/csharp/miscutil">MiscUtil</a> has more fully-developed versions of all of these classes - the code I&#39;ve written for Edulinq is the bare minimum required for the project. Due to the way I&#39;m testing (building the same tests against both Edulinq and the .NET framework version) I also don&#39;t have any tests for these classes - but they&#39;re simple enough that I&#39;m pretty confident they&#39;ll work. They don&#39;t validate constructor arguments, as the public API is responsible for using them sensibly.</p>  <p>First, projection: we want to be able to specify a key selector and optionally a comparison between two keys - just as we already do for things like ToLookup and Join, but this time using IComparer&lt;T&gt; instead of IEqualityComparer&lt;T&gt;. Here&#39;s a helper class to build a comparison for two values of a &quot;source&quot; element type based on their keys:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="ReferenceType">class</span> ProjectionComparer&lt;TElement, TKey&gt; : IComparer&lt;TElement&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> Func&lt;TElement, TKey&gt; keySelector;     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IComparer&lt;TKey&gt; comparer;     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> ProjectionComparer(Func&lt;TElement, TKey&gt; keySelector,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.keySelector = keySelector;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.comparer = comparer ?? Comparer&lt;TKey&gt;.Default;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span>&#160;<span class="ValueType">int</span> Compare(TElement x, TElement y)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TKey keyX = keySelector(x);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TKey keyY = keySelector(y);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> comparer.Compare(keyX, keyY);     <br />&#160;&#160;&#160; }     <br />} </div>  <p>As an example of how we might use this, we might want to order a List&lt;Person&gt; by last name in a case-insensitive way. For that, we might use:</p>  <div class="code">IComparer&lt;Person&gt; comparer = <span class="Keyword">new</span> ProjectionComparer&lt;Person, <span class="ReferenceType">string</span>&gt;     <br />&#160;&#160;&#160; (p =&gt; p.LastName, StringComparer.CurrentCultureIgnoreCase); </div>  <p>Again, in public code I&#39;d provide simpler ways of constructing the comparer to take advantage of type inference - but it isn&#39;t really worth it here.</p>  <p>As you can see, the comparer simply extracts the keys from both of the elements it&#39;s trying to compare, and delegates to the key comparer.</p>  <p>Next up is reversal: by reversing the order of the arguments into a comparer, we can effectively reverse the direction of a sort. Note that due to the stability of LINQ orderings, this is <em>not</em> quite the same as just reversing the final order of the elements: even when sorting by a key in a descending direction, elements with equal keys will be preserved in the original order. This actually drops out naturally when we let the comparer handle the direction - the ordering code can preserve stability without really knowing whether it&#39;s sorting in ascending or descending direction. Here&#39;s the reverse comparer:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="ReferenceType">class</span> ReverseComparer&lt;T&gt; : IComparer&lt;T&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IComparer&lt;T&gt; forwardComparer;     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> ReverseComparer(IComparer&lt;T&gt; forwardComparer)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.forwardComparer = forwardComparer;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span>&#160;<span class="ValueType">int</span> Compare(T x, T y)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> forwardComparer.Compare(y, x);     <br />&#160;&#160;&#160; }     <br />} </div>  <p>It&#39;s incredibly simple, but there are two important points to note:</p>  <ul>   <li>It actually violates the contract of IComparer&lt;T&gt;, assuming that the forward comparer doesn&#39;t. The interface documentation states that null values should compare less than any non-null references, and obviously if we&#39;re reversing the original comparison, that won&#39;t be the case. I consider this to be a flaw in the documentation, to be honest: it makes sense to allow the comparer itself to decide how to handle nullity. The LINQ ordering documentation doesn&#39;t make any specific reference to this - it&#39;s unclear whether sorting by a key in a descending manner will leave elements with a null key at the start or the end. It turns out that the .NET implementation acts like my reverse comparer: it treats null like any other value, effectively. </li>    <li>A naive implementation would call forwardComparer(x, y) and simply negate the return value. This would hide a subtle bug: if the forward comparer returned Int32.MinValue, <em>so would the reverse comparer</em>. In signed integer types, there are more negative numbers available than positive ones (e.g. the range of SByte is -128 to 127 inclusive) and negating the minimum value is effectively a no-op. By reversing the order of the arguments instead, we avoid the problem. </li> </ul>  <p>Our final helper class tackles the problem of creating a <em>compound</em> comparer, composed of a primary comparison and a secondary one. The secondary comparison is only used if the primary comparison considers two items to be equal - so for example, if we were comparing people by last name and then first name, the primary comparison would be the last name comparer, and the secondary comparison would be the first name comparer. Comparing &quot;John Smith&quot; and &quot;Fred Bloggs&quot; doesn&#39;t need to take the first names into account at all, but comparing &quot;Dave Skeet&quot; with &quot;Jon Skeet&quot; does.</p>  <p>If we want more than two comparers, we can simply treat one compound comparer as the primary comparsion for another compound comparer. For example, suppose we want to order by last name, then first name, then age. That&#39;s effectively &quot;compound(compound(last name, first name), age)&quot; in the obvious notation. Again, the code implementing a compound comparer is very simple, but will prove invaluable:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="ReferenceType">class</span> CompoundComparer&lt;T&gt; : IComparer&lt;T&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IComparer&lt;T&gt; primary;     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IComparer&lt;T&gt; secondary;     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> CompoundComparer(IComparer&lt;T&gt; primary,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IComparer&lt;T&gt; secondary)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.primary = primary;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.secondary = secondary;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span>&#160;<span class="ValueType">int</span> Compare(T x, T y)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">int</span> primaryResult = primary.Compare(x, y);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (primaryResult != 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> primaryResult;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> secondary.Compare(x, y);     <br />&#160;&#160;&#160; }     <br />} </div>  <p>(I <em>could</em> have used a conditional expression in the Compare method here, but this time I felt it wasn&#39;t worth it.)</p>  <p>With these classes in place, we can move on to look at IOrderedEnumerable - and implement some of it.</p>  <h3>Implementing IOrderedEnumerable&lt;TElement&gt;</h3>  <p>When we eventually get to OrderBy, OrderByDescending, ThenBy and ThenByDescending (in the next post) they will all return IOrderedEnumerable&lt;TElement&gt;. By focusing on that first, we can actually make the LINQ operators themselves fairly trivial. The interface itself looks simple enough:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="ReferenceType">interface</span> IOrderedEnumerable&lt;TElement&gt; : IEnumerable&lt;TElement&gt;, IEnumerable     <br />{     <br />&#160;&#160;&#160; IOrderedEnumerable&lt;TElement&gt; CreateOrderedEnumerable&lt;TKey&gt;(     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Func&lt;TElement, TKey&gt; keySelector,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">bool</span>&#160;<span class="Linq">descending</span>)     <br />} </div>  <p>The important point to understand is that most developers will never need to call CreateOrderedEnumerable directly themselves - or even care about the interface. What most of us care about is that we can call ThenBy and ThenByDescending after we&#39;ve called OrderBy or OrderByDescending - and that&#39;s what the interface enables. The ThenBy/ThenByDescending operators are extension methods on IOrderedEnumerable&lt;TElement&gt; instead of IEnumerable&lt;T&gt;, precisely because they have to be called on sequences which already have a primary ordering.</p>  <p>The CreateOrderedEnumerable method is precisely designed to create a new IOrderedEnumerable which represents the existing ordered sequence but with an extra secondary ordering applied.</p>  <p>The tricky bit to get your head round is that this sort of composition doesn&#39;t work the same way as our normal sequence chaining. Usually - for Where, Select etc - we fetch items from a &quot;parent&quot; sequence, perform some filtering or projection or whatever, and then yield the results. We can&#39;t do that to provide a secondary ordering without information about the primary ordering - we&#39;d effectively have to know where the boundaries between the &quot;primary sort keys&quot; occur, so that we only reordered within one key. Even if we could do that, it would be relatively painful from a performance perspective.</p>  <p>Instead, we need to create an IOrderedEnumerable implementation which remembers the original, unordered sequence - and then builds up a compound comparer as it goes. That way, we can then do all the ordering in one go, rather than each intermediate ordered sequence doing its own little bit.</p>  <p>This is possibly easier to show than to describe - my implementation of OrderedEnumerable is really fairly short. Here it is, just with the actual sorting code removed:</p>  <div class="code"><span class="Modifier">internal</span>&#160;<span class="ReferenceType">class</span> OrderedEnumerable&lt;TElement&gt; : IOrderedEnumerable&lt;TElement&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IEnumerable&lt;TElement&gt; source;     <br />&#160;&#160;&#160; <span class="Modifier">private</span>&#160;<span class="Modifier">readonly</span> IComparer&lt;TElement&gt; currentComparer;     <br />    <br />&#160;&#160;&#160; <span class="Modifier">internal</span> OrderedEnumerable(IEnumerable&lt;TElement&gt; source,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IComparer&lt;TElement&gt; comparer)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.source = source;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">this</span>.currentComparer = comparer;     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span> IOrderedEnumerable&lt;TElement&gt; CreateOrderedEnumerable&lt;TKey&gt;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; (Func&lt;TElement, TKey&gt; keySelector,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; IComparer&lt;TKey&gt; comparer,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="ValueType">bool</span>&#160;<span class="Linq">descending</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (keySelector == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;keySelector&quot;</span>);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IComparer&lt;TElement&gt; secondaryComparer =     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> ProjectionComparer&lt;TElement, TKey&gt; (keySelector, comparer);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (<span class="Linq">descending</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; secondaryComparer = <span class="Keyword">new</span> ReverseComparer&lt;TElement&gt;(secondaryComparer);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">new</span> OrderedEnumerable&lt;TElement&gt;(source,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> CompoundComparer&lt;TElement&gt;(currentComparer, secondaryComparer));     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Modifier">public</span> IEnumerator&lt;TElement&gt; GetEnumerator()     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Perform the actual sorting here: basically load</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// &quot;source&quot; into a buffer, and then use a stable</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// sort algorithm with &quot;currentComparer&quot; to compare</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// any two elements</span>     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; IEnumerator IEnumerable.GetEnumerator()     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> GetEnumerator();     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Note how when we create one IOrderedEnumerable from another, we don&#39;t store a reference to the original - it can be garbage-collected as far as we&#39;re concerned. We just care about the original (unordered) source, and the new compound comparer.</p>  <p>You can already see how useful our comparer helper classes are already. They allow us to focus on a single abstraction - IComparer&lt;T&gt; - and build interesting comparisons based on it, just as LINQ to Objects focuses on IEnumerable&lt;T&gt; and gives us interesting ways to work with sequences. Each aspect of the comparer we build is distinct:</p>  <ul>   <li>A projection comparer takes our key selector and key comparer, and builds a plain IComparer&lt;TElement&gt;</li>    <li>If the secondary ordering is descending, we create a reverse comparer to wrap the projection comparer</li>    <li>We then build a compound comparer from whatever comparison we were already using, and the newly created one</li> </ul>  <p>I suspect that this isn&#39;t the most efficient way to perform the comparison, to be honest: there&#39;s an awful lot of wrapping going on. However, I think it&#39;s probably the <em>clearest</em> way to represent things - and that&#39;s the goal of Edulinq.</p>  <h3>Conclusion</h3>  <p>We now have all the internal plumbing in place. There are two more tasks:</p>  <ul>   <li>Implementing the extension methods themselves</li>    <li>Performing the sort</li> </ul>  <p>I&#39;ll cover those in the next two posts (26b and 26c). In some ways, they&#39;re likely to be less interesting than this post (unless I work out a particularly interesting sort algorithm to use). It&#39;s the <em>design</em> of sorting in LINQ which I find particularly neat - the way that it&#39;s tailored to what developers really need compared with the primitive Sort methods of old, and the elegant way in which those abilities are expressed. As ever, we&#39;ve ended up with lots of small building blocks - but ones that can be combined to great effect.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
