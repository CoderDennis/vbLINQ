<html>
<head>
<title>Reimplementing LINQ to Objects: Part 5 - Empty</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 5 - Empty</h1>
<p>Continuing with the non-extension methods, it&#39;s time for possibly the simplest LINQ operator around: &quot;Empty&quot;.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb341042.aspx" target="_blank">&quot;Empty&quot;</a> is a generic, static method with just a single signature and no parameters:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt;() </div>  <p>It returns an empty sequence of the appropriate type. That&#39;s all it does.</p>  <p>There&#39;s only one bit of interesting behaviour: Empty is <em>documented</em> to cache an empty sequence. In other words, it returns a reference to the same empty sequence every time you call it (for the same type argument, of course).</p>  <h3>What are we going to test?</h3>  <p>There are really only two things we <em>can</em> test here:</p>  <ul>   <li>The returned sequence is empty </li>    <li>The returned sequence is cached on a per type argument basis </li> </ul>  <p>I&#39;m using the same approach as for Range to call the static method, but this time with an alias of EmptyClass. Here are the tests:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> EmptyContainsNoElements()     <br />{     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> empty = EmptyClass.Empty&lt;<span class="ValueType">int</span>&gt;().GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.IsFalse(empty.MoveNext());     <br />&#160;&#160;&#160; }     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> EmptyIsASingletonPerElementType()     <br />{     <br />&#160;&#160;&#160; Assert.AreSame(EmptyClass.Empty&lt;<span class="ValueType">int</span>&gt;(), EmptyClass.Empty&lt;<span class="ValueType">int</span>&gt;());     <br />&#160;&#160;&#160; Assert.AreSame(EmptyClass.Empty&lt;<span class="ValueType">long</span>&gt;(), EmptyClass.Empty&lt;<span class="ValueType">long</span>&gt;());     <br />&#160;&#160;&#160; Assert.AreSame(EmptyClass.Empty&lt;<span class="ReferenceType">string</span>&gt;(), EmptyClass.Empty&lt;<span class="ReferenceType">string</span>&gt;());     <br />&#160;&#160;&#160; Assert.AreSame(EmptyClass.Empty&lt;<span class="ReferenceType">object</span>&gt;(), EmptyClass.Empty&lt;<span class="ReferenceType">object</span>&gt;());     <br />    <br />&#160;&#160;&#160; Assert.AreNotSame(EmptyClass.Empty&lt;<span class="ValueType">long</span>&gt;(), EmptyClass.Empty&lt;<span class="ValueType">int</span>&gt;());     <br />&#160;&#160;&#160; Assert.AreNotSame(EmptyClass.Empty&lt;<span class="ReferenceType">string</span>&gt;(), EmptyClass.Empty&lt;<span class="ReferenceType">object</span>&gt;());     <br />} </div>  <p>Of course, that doesn&#39;t verify that the cache isn&#39;t per-thread, or something like that... but it&#39;ll do.</p>  <h3>Let&#39;s implement it!</h3>  <p>The implementation is actually slightly more interesting than the description so far may suggest. If it weren&#39;t for the caching aspect, we <em>could</em> just implement it like this:</p>  <div class="code"><span class="InlineComment">// Doesn&#39;t cache the empty sequence</span>     <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt;()     <br />{     <br />&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">break</span>;     <br />} </div>  <p>... but we want to obey the (somewhat vaguely) documented caching aspect too. It&#39;s not really hard, in the end. There&#39;s a very handy fact that we can use: <strong>empty arrays are immutable</strong>. Arrays always have a fixed size, but normally there&#39;s no way of making an array read-only... you can always change the value of any element. But an empty array doesn&#39;t <em>have</em> any elements, so there&#39;s nothing to change. So, we can reuse the same array over and over again, returning it directly to the caller... but only if we have an empty array of the right type.</p>  <p>At this point you <em>may</em> be expecting a <code>Dictionary&lt;Type, Array&gt;</code> or something similar... but there&#39;s another useful trick we can take advantage of. If you need a per-type cache and the type is being specific as a type argument, you can use static variables in a generic class, because each constructed type will have a distinct set of static variables.</p>  <p>Unfortunately, Empty is a generic method rather than a non-generic method in a generic type... so we&#39;ve got to create a separate generic type to act as our cache for the empty array. That&#39;s easy to do though, and the CLR takes care of initializing the type in a thread-safe way, too. So our final implementation looks like this:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt;()     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> EmptyHolder&lt;TResult&gt;.Array;     <br />}     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span>&#160;<span class="ReferenceType">class</span> EmptyHolder&lt;T&gt;     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">internal</span>&#160;<span class="Modifier">static</span>&#160;<span class="Modifier">readonly</span> T[] Array = <span class="Keyword">new</span> T[0];&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />} </div>  <p>That obeys all the caching we need, and is really simple in terms of lines of code... but it <em>does</em> mean you need to understand how generics work in .NET reasonably well. In some ways this is the opposite of the situation in the previous post - this is a sneaky implementation instead of the slower but arguably simpler dictionary-based one. In this case, I&#39;m happy with the trade-off, because once you <em>do</em> understand how generic types and static variables work, this <em>is</em> simple code. It&#39;s a case where simplicity is in the eye of the beholder.</p>  <h3>Conclusion</h3>  <p>So, that&#39;s Empty. The next operator - Repeat - is likely to be even simpler, although it&#39;ll have to be another split implementation...</p>  <h3>Addendum</h3>  <p>Due to the minor revolt over returning an array (which I still think is fine), here&#39;s an alternative implementation:</p> <div class="code"> <span class="Modifier">public</span>&nbsp;<span class="Modifier">static</span>&nbsp;IEnumerable&lt;TResult&gt;&nbsp;Empty&lt;TResult&gt;()<br /> {<br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span>&nbsp;EmptyEnumerable&lt;TResult&gt;.Instance;<br /> }<br /> <br /> <span class="PreProcessorDirective">#if</span>&nbsp;AVOID_RETURNING_ARRAYS<br /> <span class="Modifier">private</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;EmptyEnumerable&lt;T&gt;&nbsp;:&nbsp;IEnumerable&lt;T&gt;,&nbsp;IEnumerator&lt;T&gt;<br /> {<br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">internal</span>&nbsp;<span class="Modifier">static</span>&nbsp;IEnumerable&lt;T&gt;&nbsp;Instance&nbsp;=&nbsp;<span class="Keyword">new</span>&nbsp;EmptyEnumerable&lt;T&gt;();<br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Prevent&nbsp;construction&nbsp;elsewhere</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">private</span>&nbsp;EmptyEnumerable()<br /> &nbsp;&nbsp;&nbsp;&nbsp;{<br /> &nbsp;&nbsp;&nbsp;&nbsp;}<br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;IEnumerator&lt;T&gt;&nbsp;GetEnumerator()<br /> &nbsp;&nbsp;&nbsp;&nbsp;{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span>&nbsp;<span class="Keyword">this</span>;<br /> &nbsp;&nbsp;&nbsp;&nbsp;}<br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;IEnumerator&nbsp;IEnumerable.GetEnumerator()<br /> &nbsp;&nbsp;&nbsp;&nbsp;{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span>&nbsp;<span class="Keyword">this</span>;<br /> &nbsp;&nbsp;&nbsp;&nbsp;}<br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;T&nbsp;Current<br /> &nbsp;&nbsp;&nbsp;&nbsp;{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get&nbsp;{&nbsp;<span class="Statement">throw</span>&nbsp;<span class="Keyword">new</span>&nbsp;InvalidOperationException();&nbsp;}<br /> &nbsp;&nbsp;&nbsp;&nbsp;}<br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="ReferenceType">object</span>&nbsp;IEnumerator.Current<br /> &nbsp;&nbsp;&nbsp;&nbsp;{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get&nbsp;{&nbsp;<span class="Statement">throw</span>&nbsp;<span class="Keyword">new</span>&nbsp;InvalidOperationException();&nbsp;}<br /> &nbsp;&nbsp;&nbsp;&nbsp;}<br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">void</span>&nbsp;Dispose()<br /> &nbsp;&nbsp;&nbsp;&nbsp;{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;No-op</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;}<br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">bool</span>&nbsp;MoveNext()<br /> &nbsp;&nbsp;&nbsp;&nbsp;{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span>&nbsp;<span class="Keyword">false</span>;&nbsp;<span class="InlineComment">//&nbsp;There&#39;s&nbsp;never&nbsp;a&nbsp;next&nbsp;entry</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;}<br /> <br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">void</span>&nbsp;Reset()<br /> &nbsp;&nbsp;&nbsp;&nbsp;{<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;No-op</span><br /> &nbsp;&nbsp;&nbsp;&nbsp;}<br /> }<br /> <br /> <span class="PreProcessorDirective">#else</span><br /> <span class="Modifier">private</span>&nbsp;<span class="Modifier">static</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;EmptyEnumerable&lt;T&gt;<br /> {<br /> &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">internal</span>&nbsp;<span class="Modifier">static</span>&nbsp;<span class="Modifier">readonly</span>&nbsp;T[]&nbsp;Instance&nbsp;=&nbsp;<span class="Keyword">new</span>&nbsp;T[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br /> }<br /> <span class="PreProcessorDirective">#endif</span> </div> <p>Hopefully now everyone can build a version they&#39;re happy with :)</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
