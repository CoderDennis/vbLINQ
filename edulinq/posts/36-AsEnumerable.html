<html>
<head>
<title>Reimplementing LINQ to Objects: Part 36 - AsEnumerable</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 36 - AsEnumerable</h1>
<p>Our last operator is the simplest of all. Really, <em>really</em> simple.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb335435.aspx">AsEnumerable</a> has a single signature:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source) </div>  <p>I can describe its behaviour pretty easily: it returns source.</p>  <p>That&#39;s all it does. There&#39;s no argument validation, it doesn&#39;t create another iterator. It just returns source.</p>  <p>You may well be wondering what the point is... and it&#39;s all about changing the compile-time type of the expression. I&#39;m going to take about IQueryable&lt;T&gt; in another post (although probably not implement anything related to it) but hopefully you&#39;re aware that it&#39;s usually used for &quot;out of process&quot; queries - most commonly in databases.</p>  <p>Now it&#39;s not entirely uncommon to want to perform some aspects of the query in the database, and then a bit more manipulation in .NET - particularly if there are aspects you basically can&#39;t implement in LINQ to SQL (or whatever provider you&#39;re using). For example, you may want to build a particular in-memory representation which isn&#39;t really amenable to the provider&#39;s model.</p>  <p>In that case, a query can look something like this:</p>  <div class="code"><span class="Linq">var</span> query = db.Context     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Customers     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Where(c =&gt; some filter <span class="Statement">for</span> SQL)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .OrderBy(c =&gt; some ordering <span class="Statement">for</span> SQL)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(c =&gt; some projection <span class="Statement">for</span> SQL)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .AsEnumerable() <span class="InlineComment">// Switch to &quot;in-process&quot; for rest of query</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Where(c =&gt; some extra LINQ to Objects filtering)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(c =&gt; some extra LINQ to Objects projection); </div>  <p>All we&#39;re doing is changing the compile-time type of the sequence which is propagating through our query from IQueryable&lt;T&gt; to IEnumerable&lt;T&gt; - but that means that the compiler will use the methods in Enumerable (taking delegates, and executing in LINQ to Objects) instead of the ones in Queryable (taking <em>expression trees</em>, and usually executing out-of-process).</p>  <p>Sometimes we <em>could</em> do this with a simple cast or variable declaration. However, for one thing that&#39;s ugly, whereas the above query is fluent and quite readable, so long as you appreciate the importance of AsEnumerable. The more important point is that it&#39;s not always possible, because we may very well be dealing with a sequence of an anonymous type. An extension method lets the compiler use type inference to work out what the T should be for IEnumerable&lt;T&gt;, but you can&#39;t actually express that in your code.</p>  <p>In short - it&#39;s not nearly as useless an operator as it seems at first sight. That doesn&#39;t make it any more complicated to test or implement though...</p>  <h3>What are we going to test?</h3>  <p>In the spirit of exhaustive testing, I have actually tested:</p>  <ul>   <li>A normal sequence </li>    <li>A null reference </li>    <li>A sequence which would throw an exception if you actually tried to use it </li> </ul>  <p>The tests just assert that the result is the same reference as we&#39;ve passed in.</p>  <p>I have one additional test which comes as close as I can to demonstrating the point of AsEnumerable without using Queryable:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> AnonymousType()     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> list = <span class="Keyword">new</span>[] {&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { FirstName = <span class="String">&quot;Jon&quot;</span>, Surname = <span class="String">&quot;Skeet&quot;</span> },     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Keyword">new</span> { FirstName = <span class="String">&quot;Holly&quot;</span>, Surname = <span class="String">&quot;Skeet&quot;</span> }     <br />&#160;&#160;&#160; }.ToList();     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// We can&#39;t cast to IEnumerable&lt;T&gt; as we can&#39;t express T.</span>     <br />&#160;&#160;&#160; <span class="Linq">var</span> sequence = list.AsEnumerable();     <br />&#160;&#160;&#160; <span class="InlineComment">// This will now use Enumerable.Contains instead of List.Contains</span>     <br />&#160;&#160;&#160; Assert.IsFalse(sequence.Contains(<span class="Keyword">new</span> { FirstName = <span class="String">&quot;Tom&quot;</span>, Surname = <span class="String">&quot;Skeet&quot;</span> }));     <br />} </div>  <p>And finally...</p>  <h3>Let&#39;s implement it!</h3>  <p>There&#39;s not much scope for an interesting implementation here I&#39;m afraid. Here it is, in its totality:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">return</span> source;    <br />} </div>  <p>It feels like a fittingly simple end to the Edulinq implementation.</p>  <h3>Conclusion</h3>  <p>I <em>think </em>that&#39;s all I&#39;m going to actually implement from LINQ to Objects. Unless I&#39;ve missed something, that covers all the methods of Enumerable from .NET 4.</p>  <p>That&#39;s not the end of this series though. I&#39;m going to take a few days to write up some thoughts about design choices, optimizations, other operators which might have been worth including, and a little bit about how IQueryable&lt;T&gt; works.</p>  <p>Don&#39;t forget that the source code is <a href="http://edulinq.googlecode.com">freely available on Google Code</a>. I&#39;ll be happy to patch any embarrassing bugs :)</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
