<html>
<head>
<title>Reimplementing LINQ to Objects: Part 33 - Cast and OfType</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 33 - Cast and OfType</h1>
<p>More design decisions around optimization today, but possibly less controversial ones...</p>  <h3>What are they?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb341406.aspx">Cast</a> and <a href="http://msdn.microsoft.com/en-us/library/bb360913.aspx">OfType</a> are somewhat unusual LINQ operators. They are extension methods, but they work on the non-generic IEnumerable type instead of the generic IEnumerable&lt;T&gt; type:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt;(<span class="Keyword">this</span> IEnumerable source)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt;(<span class="Keyword">this</span> IEnumerable source) </div>  <p>It&#39;s worth mentioning what Cast and OfType are used for to start with. There are two main purposes:</p>  <ul>   <li>Using a non-generic collection (such as a DataTable or an ArrayList) within a LINQ query (DataTable has the AsEnumerable extension method too)</li>    <li>Changing the type of a generic collection, usually to use a more specific type (e.g. you have&#160; List&lt;Person&gt; but you&#39;re confident they&#39;re all actually Employee instances - or you only want to query against the Employee instances)</li> </ul>  <p>I can&#39;t say that I use either operator terribly often, but if you&#39;re starting off from a non-generic collection for whatever reason, these two are your only easy way to get &quot;into&quot; the LINQ world.</p>  <p>Here&#39;s a quick rundown of the behaviour they have in common:</p>  <ul>   <li>The source parameter must not be null, and this is validated eagerly </li>    <li>It uses <em>deferred execution</em>: the input sequence is not read until the output sequence is </li>    <li>It streams its data - you can use it on arbitrarily-long sequences and the extra memory required will be constant (and small :) </li> </ul>  <p>Both operators effectively try to convert each element of the input sequence to the result type (TResult). When they&#39;re successful, the results are equivalent (ignoring optimizations, which I&#39;ll come to later). The operators differ in how they handle elements which aren&#39;t of the result type.</p>  <p>Cast simply tries to cast each element to the result type. If the cast fails, it will throw an InvalidCastException in the normal way. OfType, however, sees whether each element <em>is</em> a value of the result type first - and ignores it if it&#39;s not.</p>  <p>There&#39;s one important case to consider where Cast will successfully return a value and OfType will ignore it: null references (with a nullable return type). In normal code, you can cast a null reference to any nullable type (whether that&#39;s a reference type or a nullable value type). However, if you use the &quot;is&quot; C# operator with a null value, it will always return false. Cast and OfType follow the same rules, basically.</p>  <p>It&#39;s worth noting that (as of .NET 3.5 SP1) Cast and OfType only perform reference and unboxing conversions. They <em>won&#39;t</em> convert a boxed int to a long, or execute user-defined conversions. Basically they follow the same rules as converting from object to a generic type parameter. (That&#39;s very convenient for the implementation!) In the original implementation of .NET 3.5, I believe some other conversions <em>were</em> supported (in particular, I believe that the boxed int to long conversion <em>would</em> have worked). I haven&#39;t even attempted to replicate the pre-SP1 behaviour. You can read more details in <a href="http://blogs.msdn.com/b/ed_maurer/archive/2008/02/16/breaking-change-in-linq-queries-using-explicitly-typed-range-variables.aspx">Ed Maurer&#39;s blog post</a> from 2008.</p>  <p>There&#39;s one final aspect to discuss: optimization. If &quot;source&quot; already implements IEnumerable&lt;TResult&gt;, the Cast operator just returns the parameter directly, within the original method call. (In other words, this behaviour isn&#39;t deferred.) Basically we know that every cast will succeed, so there&#39;s no harm in returning the input sequence. This means you <em>shouldn&#39;t</em> use Cast as an &quot;isolation&quot; call to protect your original data source, in the same way as we sometimes use Select with an identity projection. See Eric Lippert&#39;s <a href="http://blogs.msdn.com/b/ericlippert/archive/2008/05/12/trivial-projections-are-usually-optimized-away.aspx">blog post on degenerate queries</a> for more about protecting the original source of a query.</p>  <p>In the LINQ to Objects implementation, OfType <em>never</em> returns the source directly. It <em>always</em> uses an iterator. Most of the time, it&#39;s probably right to do so. Just because something implements IEnumerable&lt;string&gt; doesn&#39;t mean everything within it should be returned by OfType... because some elements may be null. The same is true of an IEnumerable&lt;int?&gt; - but <em>not</em> an IEnumerable&lt;int&gt;. For a non-nullable value type T, if source implements IEnumerable&lt;T&gt; then source.OfType&lt;T&gt;() will always contain the exact same sequence of elements as source. It does no more harm to return source from OfType() here than it does from Cast().</p>  <h3>What are we going to test?</h3>  <p>There are &quot;obvious&quot; tests for deferred execution and eager argument validation. Beyond that, I effectively have two types of test: ones which focus on whether the call returns the original argument, and ones which test the behaviour of iterating over the results (including whether or not an exception is thrown).</p>  <p>The iteration tests are generally not that interesting - in particular, they&#39;re similar to tests we&#39;ve got everywhere else. The &quot;identity&quot; tests are more interesting, because they show some differences between conversions that are allowed by the CLR and those allowed by C#. It&#39;s obvious that an array of strings is going to be convertible to IEnumerable&lt;string&gt;, but a test like this might give you more pause for thought:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> OriginalSourceReturnedForInt32ArrayToUInt32SequenceConversion()     <br />{     <br />&#160;&#160;&#160; IEnumerable enums = <span class="Keyword">new</span>&#160;<span class="ValueType">int</span>[10];     <br />&#160;&#160;&#160; Assert.AreSame(enums, enums.Cast&lt;<span class="ValueType">uint</span>&gt;());     <br />} </div>  <p>That&#39;s trying to &quot;cast&quot; an int[] to an IEnumerable&lt;uint&gt;. If you try the same in normal C# code, it will fail - although if you cast it to &quot;object&quot; first (to distract the compiler, as it were) it&#39;s fine at both compile time and execution time:</p>  <div class="code"><span class="ValueType">int</span>[] ints = <span class="Keyword">new</span>&#160;<span class="ValueType">int</span>[10];     <br /><span class="InlineComment">// Fails with CS0030</span>     <br />IEnumerable&lt;<span class="ValueType">uint</span>&gt; uints = (IEnumerable&lt;<span class="ValueType">uint</span>&gt;) ints;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="InlineComment">// Succeeds at execution time</span>     <br />IEnumerable&lt;<span class="ValueType">uint</span>&gt; uints = (IEnumerable&lt;<span class="ValueType">uint</span>&gt;)(<span class="ReferenceType">object</span>) ints; </div>  <p>We can have a bit more fun at the compiler&#39;s expense, and note its arrogance:</p>  <div class="code"><span class="ValueType">int</span>[] ints = <span class="Keyword">new</span>&#160;<span class="ValueType">int</span>[10];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br /><span class="Statement">if</span> (ints <span class="Keyword">is</span> IEnumerable&lt;<span class="ValueType">uint</span>&gt;)     <br />{     <br />&#160;&#160;&#160; Console.WriteLine(<span class="String">&quot;This won&#39;t be printed&quot;</span>);     <br />}     <br /><span class="Statement">if</span> (((<span class="ReferenceType">object</span>) ints) <span class="Keyword">is</span> IEnumerable&lt;<span class="ValueType">uint</span>&gt;)     <br />{     <br />&#160;&#160;&#160; Console.WriteLine(<span class="String">&quot;This will be printed&quot;</span>);     <br />} </div>  <p>This generates a warning for the first block &quot;The given expression is never of the provided (...) type&quot; and the compiler has the cheek to remove the block entirely... despite the fact that it <em>would</em> have worked if only it had been emitted as code.</p>  <p>Now, I&#39;m not <em>really</em> trying to have a dig at the C# team here - the compiler is actually acting entirely reasonably within the rules of C#. It&#39;s just that the CLR has subtly different rules around conversions - so when the compiler makes a prediction about what <em>would</em> happen with a particular cast or &quot;is&quot; test, it can be wrong. I don&#39;t think this has ever bitten me as an issue, but it&#39;s quite fun to watch. As well as this signed/unsigned difference, there are similar conversions between arrays of enums and their underlying types.</p>  <p>There&#39;s another type of conversion which is interesting:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> OriginalSourceReturnedDueToGenericCovariance()     <br />{     <br />&#160;&#160;&#160; IEnumerable strings = <span class="Keyword">new</span> List&lt;<span class="ReferenceType">string</span>&gt;();     <br />&#160;&#160;&#160; Assert.AreSame(strings, strings.Cast&lt;<span class="ReferenceType">object</span>&gt;());     <br />} </div>  <p>This takes advantage of the generic variance introduced in .NET 4 - sort of. There is now a reference conversion from List&lt;string&gt; to IEnumerable&lt;object&gt; which wouldn&#39;t have worked in .NET 3.5. However, this isn&#39;t due to the fact that C# 4 now knows about variance; the compiler isn&#39;t verifying the conversion here, after all. It isn&#39;t due to a new feature in the CLRv4 - generic variance for interfaces and delegates has been present since generics were introduced in CLRv2. It&#39;s only due to the change in the IEnumerable&lt;T&gt; type, which has become IEnumerable&lt;out T&gt; in .NET 4. If you could make the same change to the standard library used in .NET 3.5, I believe the test above would pass. (It&#39;s possible that the precise CLR rules for variance changed between CLRv2 and CLRv4 - I don&#39;t think this variance was widely used before .NET 4, so the risk of it being a problematically-breaking change would have been slim.)</p>  <p>In addition to all these functional tests, I&#39;ve included a couple of tests to show that the compiler uses Cast in query expressions if you give a range variable an explicit type. This works for both &quot;from&quot; and &quot;join&quot;:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> CastWithFrom()     <br />{     <br />&#160;&#160;&#160; IEnumerable strings = <span class="Keyword">new</span>[] { <span class="String">&quot;first&quot;</span>, <span class="String">&quot;second&quot;</span>, <span class="String">&quot;third&quot;</span> };     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = <span class="Linq">from</span>&#160;<span class="ReferenceType">string</span> x <span class="Statement">in</span> strings     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> x;     <br />&#160;&#160;&#160; query.AssertSequenceEqual(<span class="String">&quot;first&quot;</span>, <span class="String">&quot;second&quot;</span>, <span class="String">&quot;third&quot;</span>);     <br />}     <br />    <br />[Test]     <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> CastWithJoin()     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> ints = Enumerable.Range(0, 10);     <br />&#160;&#160;&#160; IEnumerable strings = <span class="Keyword">new</span>[] { <span class="String">&quot;first&quot;</span>, <span class="String">&quot;second&quot;</span>, <span class="String">&quot;third&quot;</span> };     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = <span class="Linq">from</span> x <span class="Statement">in</span> ints     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">join</span>&#160;<span class="ReferenceType">string</span> y <span class="Statement">in</span> strings <span class="Linq">on</span> x <span class="Linq">equals</span> y.Length     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> x + <span class="String">&quot;:&quot;</span> + y;     <br />&#160;&#160;&#160; query.AssertSequenceEqual(<span class="String">&quot;5:first&quot;</span>, <span class="String">&quot;5:third&quot;</span>, <span class="String">&quot;6:second&quot;</span>);     <br />} </div>  <p>Note how the compile-time type of &quot;strings&quot; is just IEnumerable in both cases. We couldn&#39;t use this in a query expression normally, because LINQ requires generic sequences - but by giving the range variables explicit types, the compiler has inserted a call to Cast which makes the rest of the translation work.</p>  <h3>Let&#39;s implement them!</h3>  <p>The &quot;eager argument validation, deferred sequence reading&quot; mode of Cast and OfType means we&#39;ll use the familiar approach of a non-iterator-block public method which finally calls an iterator block if it gets that far. This time, however, the optimization occurs within the public method. Here&#39;s Cast, to start with:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt;(<span class="Keyword">this</span> IEnumerable source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; IEnumerable&lt;TResult&gt; existingSequence = source <span class="Keyword">as</span> IEnumerable&lt;TResult&gt;;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (existingSequence != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> existingSequence;     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> CastImpl&lt;TResult&gt;(source);     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; CastImpl&lt;TResult&gt;(IEnumerable source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="ReferenceType">object</span> item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> (TResult) item;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>We&#39;re using the normal as/null-test to check whether we can just return the source directly, and in the loop we&#39;re casting. We <em>could</em> have made the iterator block very slightly shorter here, using the behaviour of foreach to our advantage:</p>  <div class="code"><span class="Statement">foreach</span> (TResult item <span class="Statement">in</span> source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />} </div>  <p>Yikes! Where&#39;s the cast gone? How can this possibly work? Well, the cast is still there - it&#39;s just been inserted automatically by the compiler. It&#39;s the invisible cast that was present in almost every foreach loop in C# 1. The fact that it <em>is</em> invisible is the reason I&#39;ve chosen the previous version. The point of the method is to cast each element - so it&#39;s pretty important to make the cast as obvious as possible.</p>  <p>So that&#39;s Cast. Now for OfType. First let&#39;s look at the public entry point:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt;(<span class="Keyword">this</span> IEnumerable source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (<span class="Modifier">default</span>(TResult) != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IEnumerable&lt;TResult&gt; existingSequence = source <span class="Keyword">as</span> IEnumerable&lt;TResult&gt;;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (existingSequence != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> existingSequence;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> OfTypeImpl&lt;TResult&gt;(source);     <br />} </div>  <p>This is <em>almost</em> the same as Cast, but with the additional test of &quot;default(TResult) != null&quot; before we check whether the input sequence is an IEnumerable&lt;TResult&gt;. That&#39;s a simple way of saying, &quot;Is this a non-nullablle value type.&quot; I don&#39;t know for sure, but I&#39;d <em>hope</em> that when the JIT compiler looks at this method, it can completely wipe out the test, either removing the body of the if statement completely for nullable value types and reference types, or just go execute the body unconditionally for non-nullable value types. It really doesn&#39;t matter if JIT <em>doesn&#39;t</em> do this, but one day I may get up the courage to tackle this with cordbg and find out for sure... but not tonight.</p>  <p>Once we&#39;ve decided we&#39;ve got to iterate over the results ourselves, the iterator block method is quite simple:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; OfTypeImpl&lt;TResult&gt;(IEnumerable source)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="ReferenceType">object</span> item <span class="Statement">in</span> source)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (item <span class="Keyword">is</span> TResult)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> (TResult) item;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />} </div>  <p>Note that we can&#39;t use the &quot;as and check for null&quot; test here, because we don&#39;t know that TResult is a nullable type. I was <em>tempted</em> to try to write two versions of this code - one for reference types and one for value types. (I&#39;ve <a href="http://stackoverflow.com/questions/1583050/performance-surprise-with-as-and-nullable-types">found before</a> that using &quot;as and check for null&quot; is really slow for nullable value types. That may change, of course.) However, that would be quite tricky and I&#39;m not convinced it would have much impact. I did a quick test yesterday testing whether an &quot;object&quot; was actually a &quot;string&quot;, and the is+cast approach seemed just as good. I suspect that may be because string is a sealed class, however... testing for an interface or a non-sealed class <em>may</em> be more expensive. Either way, it would be premature to write a complicated optimization without testing first.</p>  <h3>Conclusion</h3>  <p>It&#39;s not clear to me why Microsoft optimizes Cast but not OfType. There&#39;s a possibility that I&#39;ve missed a reason why OfType shouldn&#39;t be optimized even for a sequence of non-nullable value type values - if you can think of one, please point it out in the comments. My immediate objection would be that it &quot;reveals&quot; the source of the query... but as we&#39;ve seen, Cast already does that sometimes, so I don&#39;t think that theory holds.</p>  <p>Other than that decision, the rest of the <em>implementation</em> of these operators has been pretty plain sailing. It did give us a quick glimpse into the difference between the conversions that the CLR allows and the ones that the C# specification allows though, and that&#39;s always fun.</p>  <p>Next up - SequenceEqual.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
