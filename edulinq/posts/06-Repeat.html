<html>
<head>
<title>Reimplementing LINQ to Objects: Part 6 - Repeat</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 6 - Repeat</h1>
<p>A trivial method next, with even less to talk about than &quot;Empty&quot;... &quot;Repeat&quot;. This blog post is merely a matter of completeness.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb348899.aspx" target="_blank">&quot;Repeat&quot;</a> is a static, generic non-extension method with a single overload:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt;(     <br />&#160;&#160;&#160; TResult element,     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count) </div>  <p>It simple returns a sequence which contains the specified element, repeated &quot;count&quot; times. The only argument validation is that &quot;count&quot; has to be non-negative.</p>  <h3>What are we going to test?</h3>  <p>There&#39;s really not a lot to test here. I&#39;ve thought of 4 different scenarios:</p>  <ul>   <li>A vanilla &quot;repeat a string 3 times&quot; sequence </li>    <li>An empty sequence (repeat an element 0 times) </li>    <li>A sequence containing null values (just to prove that &quot;element&quot; can be null) </li>    <li>A negative count to prove that argument validation occurs, and does so eagerly. </li> </ul>  <p>None of this is remotely exciting, I&#39;m afraid.</p>  <h3>Let&#39;s implement it!</h3>  <p>Just about the only thing we could do wrong here is to put the argument validation directly in an iterator block... and we&#39;ve implemented the &quot;split method&quot; pattern so many times already that we wouldn&#39;t fall into that trap. So, here&#39;s the code in all its tedious lack of glory:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt;(TResult element, <span class="ValueType">int</span> count)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (count &lt; 0)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentOutOfRangeException(<span class="String">&quot;count&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> RepeatImpl(element, count);     <br />}     <br />    <br /><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; RepeatImpl&lt;TResult&gt;(TResult element, <span class="ValueType">int</span> count)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = 0; i &lt; count; i++)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> element;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>That&#39;s it. Um, interesting points to note... none.</p>  <h3>Conclusion</h3>  <p>There&#39;s no sense in dragging this out. That&#39;s the lot. Next up, Count and LongCount - which actually <em>do</em> have a couple of interesting points.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
