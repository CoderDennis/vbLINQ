<html>
<head>
<title>Reimplementing LINQ to Objects: Part 43 - Out-of-process queries with IQueryable</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 43 - Out-of-process queries with IQueryable</h1>
<p>I&#39;ve been putting off writing about this for a while now, mostly because it&#39;s such a huge topic. I&#39;m not going to try to give more than a brief introduction to it here - don&#39;t expect to be able to whip up your own LINQ to SQL implementation afterwards - but it&#39;s worth at least having an idea of what happens when you use something like LINQ to SQL, NHibernate or the Entity Framework.</p>  <p>Just as LINQ to Objects is primarily interested in IEnumerable&lt;T&gt; and the static Enumerable class, so out-of-process LINQ is primarily interested in IQueryable&lt;T&gt; and the static Queryable class... but before we get to them, we need to talk about expression trees.</p>  <h3>Expression Trees</h3>  <p>To put it in a nutshell, expression trees encapsulate logic in <em>data</em> instead of <em>code</em>. While you <em>can</em> introspect .NET code via <a href="http://msdn.microsoft.com/en-us/library/system.reflection.methodbase.getmethodbody.aspx">MethodBase.GetMethodBody</a> and then <a href="http://msdn.microsoft.com/en-us/library/system.reflection.methodbody.getilasbytearray.aspx">MethodBody.GetILAsByteArray</a>, that&#39;s not really a practical approach. The types in the <a href="http://msdn.microsoft.com/en-us/library/system.linq.expressions.aspx">System.Linq.Expressions</a> define expressions in an easier-to-process manner. When expression trees were introduced in .NET 3.5, they were strictly for <em>expressions</em>, but the Dynamic Language Runtime uses expression trees to represent operations, and the range of logic represented had to expand accordingly, to include things like blocks.</p>  <p>While you certainly <em>can</em> build expression trees yourself (usually via the factory methods on the nongeneric <a href="http://msdn.microsoft.com/en-us/library/system.linq.expressions.expression.aspx">Expression</a> class), and it&#39;s fun to do so at times, the most common way of creating them is to use the C# compiler&#39;s support for them via lambda expressions. So far we&#39;ve always seen a lambda expression being converted to a delegate, but it can also convert lambdas to instances of <a href="http://msdn.microsoft.com/en-us/library/bb335710.aspx">Expression&lt;TDelegate&gt;</a>, where TDelegate is a delegate type which is compatible with the lambda expression. A concrete example will help here. The statement:</p>  <div class="code">Expression&lt;Func&lt;<span class="ValueType">int</span>, <span class="ValueType">int</span>&gt;&gt; addOne = x =&gt; x + 1; </div>  <p>will be compiled into code which is <i>effectively</i> something like this:</p>  <div class="code"><span class="Linq">var</span> parameter = Expression.Parameter(<span class="Keyword">typeof</span>(<span class="ValueType">int</span>), <span class="String">&quot;x&quot;</span>);     <br /><span class="Linq">var</span> one = Expression.Constant(1, <span class="Keyword">typeof</span>(<span class="ValueType">int</span>));     <br /><span class="Linq">var</span> addition = Expression.Add(parameter, one);     <br /><span class="Linq">var</span> addOne = Expression.Lambda&lt;Func&lt;<span class="ValueType">int</span>, <span class="ValueType">int</span>&gt;&gt;(addition,&#160; <span class="Keyword">new</span> ParameterExpression[] { parameter }); </div>  <p>The compiler has some tricks up its sleeves which allow it to refer to methods, events and the like in a simpler way than we can from code, but largely you can regard the transformation as just a way of making life a <em>lot</em> simpler than if you had to build the expression trees yourself every time.</p>  <h3>IQueryable, IQueryable&lt;T&gt; and IQueryProvider</h3>  <p>Now that we&#39;ve got the idea of being able to inspect logic relatively easily at execution time, let&#39;s see how it applies to LINQ.</p>  <p>There are three interfaces to introduce, and it&#39;s probably easiest to start with how they appear in a class diagram:</p>  <p><img style="margin:5px 5px 5px 0px;" src="IQueryable.png" alt="interface diagram" /></p>  <p>Most of the time, queries are represented using the generic <a href="http://msdn.microsoft.com/en-us/library/bb351562.aspx">IQueryable&lt;T&gt;</a> interface, but this doesn&#39;t actually add much over the nongeneric <a href="http://msdn.microsoft.com/en-us/library/system.linq.iqueryable.aspx">IQueryable</a> interface it extends, other than <em>also</em> extending IEnumerable&lt;T&gt; - so you can iterate over the contents of an IQueryable&lt;T&gt; just as with any other sequence.</p>  <p>IQueryable contains the interesting bits, in the form of three properties: <a href="http://msdn.microsoft.com/en-us/library/system.linq.iqueryable.elementtype.aspx">ElementType</a> which indicates the type of the elements within the query (in other words, a dynamic form of the T from IQueryable&lt;T&gt;), <a href="http://msdn.microsoft.com/en-us/library/system.linq.iqueryable.expression.aspx">Expression</a> returns the expression tree for the query so far, and <a href="http://msdn.microsoft.com/en-us/library/system.linq.iqueryable.provider.aspx">Provider</a> returns the query provider which is responsible for creating <em>new</em> queries and executing the existing one. We won&#39;t need to use the ElementType property ourselves, but we&#39;ll need both the Provider and Expression properties.</p>  <h3>The static Queryable class</h3>  <p>We&#39;re not going to implement any of the interfaces ourselves, but I&#39;ve got a small sample program to demonstrate how they all work, imagining we were implementing most of <a href="http://msdn.microsoft.com/en-us/library/system.linq.queryable.aspx">Queryable</a> ourselves. This static class contains extension methods for IQueryable&lt;T&gt; just as Enumerable does for IEnumerable&lt;T&gt;. <em>Most</em> of the query operators from LINQ to Objects appear in Queryable as well, but there are a few notable omissions, such as the To{Lookup, Array, List, Dictionary} methods. If you call one of those on an IQueryable&lt;T&gt;, the Enumerable implementations will be used instead. (IQueryable&lt;T&gt; extends IEnumerable&lt;T&gt;, so the extension methods in Enumerable are applicable to IQueryable&lt;T&gt; sequences as well.)</p>  <p>The big difference between the Queryable and Enumerable methods in terms of their <em>declarations</em> is in the parameters:</p>  <ul>   <li>The &quot;source&quot; parameter in Queryable is always of type IQueryable&lt;TSource&gt; instead of IEnumerable&lt;TSource&gt;. (Other sequence parameters such as the sequence to concatenate for Queryable.Concat are expressed as IEnumerable&lt;T&gt;, interestingly enough. This allows you to express a SQL query using &quot;local&quot; data as well; the query methods work out whether the sequence is actually an IQueryable&lt;T&gt; and act accordingly.) </li>    <li>Any parameters which were delegates in Enumerable are expression trees in Queryable; so while the selector parameter in Enumerable.Select is of type Func&lt;TSource, TResult&gt;, the equivalent in Queryable.Select is of type Expression&lt;Func&lt;TSource, TResult&gt;&gt; </li> </ul>  <p>The big difference between the methods in terms of what they <em>do</em> is that whereas the Enumerable methods actually do the work (eventually - possibly after deferred execution of course), the Queryable methods themselves really <em>don&#39;t</em> do any work: they just ask the query provider to build up a query indicating that they&#39;ve been called.</p>  <p>Let&#39;s have a look at Where for example. If we wanted to implement Queryable.Where, we would have to:</p>  <ul>   <li>Perform argument checking </li>    <li>Get the &quot;current&quot; query&#39;s Expression </li>    <li>Build a new expression representing a call to Queryable.Where using the current expression as the source, and the predicate expression as the predicate </li>    <li>Ask the current query&#39;s provider to build a new IQueryable&lt;T&gt; based on that call expression, and return it. </li> </ul>  <p>It all sounds a bit recursive, I realize - the Where call needs to record that a Where call has happened... but that&#39;s all. You may very well wonder where all the work is happening. We&#39;ll come to that.</p>  <p>Now building a call expression is slightly tedious because you need to have the right MethodInfo - and as Where is overloaded, that means distinguishing between the two Where methods, which is easier said than done. I&#39;ve actually used a LINQ query to find the right overload - the one where the predicate parameter Expression&lt;Func&lt;T, bool&gt;&gt; rather than Expression&lt;Func&lt;T, int, bool&gt;&gt;. In the .NET implementation, methods can use <a href="http://msdn.microsoft.com/en-us/library/system.reflection.methodbase.getcurrentmethod.aspx">MethodBase.GetCurrentMethod()</a> instead... although equally they could have created a bunch of static variables computed at class initialization time. We can&#39;t use GetCurrentMethod() for experimentation purposes, because the query provider is likely to expect the exact correct method from System.Linq.Queryable in the System.Core assembly.</p>  <p>Here&#39;s our sample implementation, broken up quite a lot to make it easier to understand:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IQueryable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Expression&lt;Func&lt;TSource, <span class="ValueType">bool</span>&gt;&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (predicate == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; Expression sourceExpression = source.Expression;     <br />&#160;&#160;&#160; Expression quotedPredicate = Expression.Quote(predicate);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span class="InlineComment">// This gets the &quot;open&quot; method, without specific type arguments. The second parameter</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// of the method we want is of type Expression&lt;Func&lt;TSource, bool&gt;&gt;, so the sole generic</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// type argument to Expression&lt;T&gt; itself has two generic type arguments.</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// Let&#39;s face it, reflection on generic methods is a mess.</span>     <br />&#160;&#160;&#160; MethodInfo method = <span class="Keyword">typeof</span>(Queryable).GetMethods()     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Where(m =&gt; m.Name == <span class="String">&quot;Where&quot;</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Where(m =&gt; m.GetParameters()[1]     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .ParameterType     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .GetGenericArguments()[0]     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .GetGenericArguments().Length == 2)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .First();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span class="InlineComment">// This gets the method with the same type arguments as ours</span>     <br />&#160;&#160;&#160; MethodInfo closedMethod = method.MakeGenericMethod(<span class="Keyword">new</span> Type[] { <span class="Keyword">typeof</span>(TSource) });     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span class="InlineComment">// Now we can create a *representation* of this exact method call</span>     <br />&#160;&#160;&#160; Expression methodCall = Expression.Call(closedMethod, sourceExpression, quotedPredicate);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span class="InlineComment">// ... and ask our query provider to create a query for it</span>     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.Provider.CreateQuery&lt;TSource&gt;(methodCall);     <br />} </div>  <p>There&#39;s only one part of this code that I don&#39;t really understand the need for, and that&#39;s the call to Expression.Quote on the predicate expression tree. I&#39;m sure there&#39;s a good reason for it, but <em>this particular example</em> would work without it, as far as I can see. The real implementation uses it though, so dare say it&#39;s required in some way.</p>  <p>EDIT: Daniel&#39;s comment has made this somewhat clearer to me. Each of the arguments to Expression.Call after the MethodInfo itself is meant to be an expression which represents the argument to the method call. In our example we need an expression which represents an argument of type Expression&lt;Func&lt;TSource, bool&gt;&gt;. We already have the value, but we need to provide the layer of wrapping... just as we did with Expression.Constant in the very first expression tree I showed at the top. To wrap the expression value we&#39;ve got, we use Expression.Quote. It&#39;s still not clear to me <em>exactly</em> why we can use Expression.Quote but not Expression.Constant, but at least it&#39;s clearer why we need <em>something</em>...</p>  <p>EDIT: I&#39;m gradually getting there. <a href="http://stackoverflow.com/questions/3716492/what-does-expression-quote-do-that-expression-constant-cant-already-do">This Stack Overflow answer from Eric Lippert</a> has much to say on the topic. I&#39;m still trying to get my head round it, but I&#39;m sure when I&#39;ve read Eric&#39;s answer several times, I&#39;ll get there.</p>  <p>We can even test that this works, by using the <a href="http://msdn.microsoft.com/en-us/library/bb353734.aspx">Queryable.AsQueryable</a> method from the real .NET implementation. This creates an IQuerable&lt;T&gt; from any IEnumerable&lt;T&gt; using a built-in query provider. Here&#39;s the test program, where FakeQueryable is a static class containing the extension method above:</p>  <div class="code"><span class="Namespace">using</span> System;     <br /><span class="Namespace">using</span> System.Collections.Generic;     <br /><span class="Namespace">using</span> System.Linq;     <br />    <br /><span class="ReferenceType">class</span> Test     <br />{     <br />&#160;&#160;&#160; <span class="Modifier">static</span>&#160;<span class="ValueType">void</span> Main()     <br />&#160;&#160;&#160; {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; List&lt;<span class="ValueType">int</span>&gt; list = <span class="Keyword">new</span> List&lt;<span class="ValueType">int</span>&gt; { 3, 5, 1 };     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IQueryable&lt;<span class="ValueType">int</span>&gt; source = list.AsQueryable();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IQueryable&lt;<span class="ValueType">int</span>&gt; query = FakeQueryable.Where(source, x =&gt; x &gt; 2);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="ValueType">int</span> value <span class="Statement">in</span> query)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(value);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>This works, printing just 3 and 5, filtering out the 1. Yay! (I&#39;m explicitly calling FakeQueryable.Where rather than letting extension method resolution find it, just to make things clearer.)</p>  <p>Um, but what&#39;s doing the actual work? We&#39;ve implemented the Where clause without providing any filtering ourselves. It&#39;s really the query provider which has built an appropriate IQueryable&lt;T&gt; implementation. When we call GetEnumerator() implicitly in the foreach loop, the query can examine everything that&#39;s built up in the expression tree (which could contain multiple operators - it&#39;s nesting queries within queries, essentially) and work out what to do. In the case of our IQueryable&lt;T&gt; built from a list, it just does the filtering in-process... but if we were using LINQ to SQL, <em>that&#39;s</em> when the SQL would be generated. The provider recognizes the specific methods from Queryable, and applies filters, projections etc. That&#39;s why it was important that our demo Where method pretended that the real Queryable.Where had been called - otherwise the query provider wouldn&#39;t know what the call expression </p>  <p>Just to hammer the point home even further... Queryable itself neither knows nor cares what kind of data source you&#39;re using. Its job is <em>not</em> to perform any query operations itself; its job is to <em>record</em> the requested query operations in a source-agnostic manner, and let the source provider handle them when it needs to.</p>  <h3>Immediate execution with IQueryProvider.Execute</h3>  <p>All the operators using deferred execution in Queryable are implemented in much the same way as our demo Where method. However, that doesn&#39;t cover the situation where we need to execute the query <em>now</em>, because it has to return a value directly instead of another query.</p>  <p>This time I&#39;m going to use ElementAt as the sample, simply because it&#39;s only got one overload, which makes it very easy to grab the relevant MethodInfo. The general procedure is exactly the same as building a new query, except that this time we call the provider&#39;s Execute method instead of CreateQuery.</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource ElementAt&lt;TSource&gt;(<span class="Keyword">this</span> IQueryable&lt;TSource&gt; source, <span class="ValueType">int</span> index)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; Expression sourceExpression = source.Expression;     <br />&#160;&#160;&#160; Expression indexExpression = Expression.Constant(index);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; MethodInfo method = <span class="Keyword">typeof</span>(Queryable).GetMethod(<span class="String">&quot;ElementAt&quot;</span>);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; MethodInfo closedMethod = method.MakeGenericMethod(<span class="Keyword">new</span> Type[] { <span class="Keyword">typeof</span>(TSource) });     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span class="InlineComment">// Now we can create a *representation* of this exact method call</span>     <br />&#160;&#160;&#160; Expression methodCall = Expression.Call(closedMethod, sourceExpression, indexExpression);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span class="InlineComment">// ... and ask our query provider to execute it</span>     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.Provider.Execute&lt;TSource&gt;(methodCall);     <br />} </div>  <p>The type argument we provide to Execute is the desired <em>return</em> type - so for Count, we&#39;d call Execute&lt;int&gt; for example. Again, it&#39;s up to the query provider to work out what the call actually means.</p>  <p>It&#39;s worth mentioning that both CreateQuery and Execute have generic and non-generic overloads. I haven&#39;t personally encountered a use for the non-generic ones, but I gather they&#39;re useful for various situations in generated code, particularly if you really don&#39;t know the element type - or at least only know it dynamically, and don&#39;t want to have to use reflection to generate an appropriate generic method call.</p>  <h3>Transparent support in source code</h3>  <p>One of the aspects of LINQ which raises it to the &quot;genius&quot; status (and &quot;slightly scary&quot; at the same time) is that most of the time, most developers don&#39;t need to make any changes to their source code in order to use Enumerable or Queryable. Take this query expression and its translation:</p>  <div class="code"><span class="Linq">var</span> query = <span class="Linq">from</span> person <span class="Statement">in</span> family     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">where</span> person.LastName == <span class="String">&quot;Skeet&quot;</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> person.FirstName;     <br />    <br /><span class="InlineComment">// Translation</span>     <br /><span class="Linq">var</span> query = family.Where(person =&gt; person.LastName == <span class="String">&quot;Skeet&quot;</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(person =&gt; person.FirstName); </div>  <p>Which set of query methods will that use? It entirely depends on the compile-time type of the &quot;family&quot; variable. If that&#39;s a type which implements IQueryable&lt;T&gt;, it will use the extension methods in Queryable, the lambda expression will be converted into expression trees, and the type of &quot;query&quot; will be IQueryable&lt;string&gt;. Otherwise (and assuming the type implements IEnumerable&lt;T&gt; isn&#39;t some other interesting type such as <a href="http://msdn.microsoft.com/en-us/library/system.linq.parallelenumerable.aspx">ParallelEnumerable</a>) it will use the extension methods in Enumerable, the lambda expressions will be converted into delgeates, and the type of &quot;query&quot; will be IEnumerable&lt;string&gt;.</p>  <p>The query expression translation part of the specification has no need to care about this, because it&#39;s simply translating into a form which uses lambda expressions - the rest of overload resolution and lambda expression conversion deals with the details.</p>  <p>Genius... although it does mean you need to be careful that <em>really</em> you know where your query evaluation is going to take place - you don&#39;t want to accidentally end up performing your whole query in-process having shipped the entire contents of a database across a network connection...</p>  <h3>Conclusion</h3>  <p>This was really a whistlestop tour of the &quot;other&quot; side of LINQ - and without going into any of the details of the real providers such as LINQ to SQL. However, I hope it&#39;s given you enough of a flavour for what&#39;s going on to appreciate the general design. Highlights:</p>  <ul>   <li><em>Expression trees</em> are used to capture logic in a data structure which can be examined relatively easily at execution time </li>    <li>Lambda expressions can be converted into expression trees as well as delegates </li>    <li>IQueryable&lt;T&gt; and IQueryable form a sort of parallel interface hierarchy to IEnumerable&lt;T&gt; and IEnumerable - although the queryable forms extend the enumerable forms </li>    <li>IQueryProvider enables one query to be built based on another, or executed immediately where appropriate </li>    <li>Queryable provides equivalent extension methods to most of the Enumerable LINQ operators, except that it uses IQueryable&lt;T&gt; sources and expression trees instead of delegates </li>    <li>Queryable doesn&#39;t handle the queries itself at all; it simply records what&#39;s been called and delegates the real processing to the query provider </li> </ul>  <p>I <em>think</em> I&#39;ve now covered most of the topics I wanted to mention after finishing the actual Edulinq implementation. Next up I&#39;ll talk about some of the thorny design issues (most of which I&#39;ve already mentioned, but which bear repeating) and then I&#39;ll write a brief &quot;series conclusion&quot; post with a list of links to all the other parts.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
