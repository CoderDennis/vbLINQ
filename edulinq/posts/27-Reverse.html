<html>
<head>
<title>Reimplementing LINQ to Objects: Part 27 - Reverse</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 27 - Reverse</h1>
<p>Time for a change of pace after the deep dive into sorting. Reversing is pretty simple... which is not to say there&#39;s nothing to discuss, of course.</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb358497.aspx">Reverse</a> only has a single, simple signature:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; Reverse&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source) </div>  <p>The behaviour is pretty simple to describe:</p>  <ul>   <li>source cannot be null; this is validated eagerly. </li>    <li>The operator uses deferred execution: until you start reading from the result, it won&#39;t read anything from the input sequence </li>    <li>As soon as you start reading from the result sequence, the input sequence is read in its entirety </li>    <li>The result sequence contains all the elements of the input sequence, in the opposite order. (So the first element of the result sequence is the last element of the input sequence.) </li> </ul>  <p>The third point is the most interesting. It sounds like an obvious requirement just to get it to work at all - until you think of possible optimizations. Imagine if you implemented Reverse with an optimization for arrays: we know the array won&#39;t change size, and we can find out that size easily enough - so we could just use the indexer on each iteration, starting off with an index of &quot;length - 1&quot; and decrementing until we&#39;d yielded every value.</p>  <p>LINQ to Objects <em>doesn&#39;t</em> behave this way - and that&#39;s observable because if you change the value of the array after you start iterating over the result sequence, you don&#39;t see those changes. Deferred execution means that you <em>will</em> see changes made to the array after the call to Reverse but before you start iterating over the results, however.</p>  <p>Note that the buffering nature of this operator means that you can&#39;t use it on infinite sequences - which makes sense when you think about it. What&#39;s the last element of an infinite sequence?</p>  <h3>What are we going to test?</h3>  <p>Most of the tests are pretty obvious, but I have one test to demonstrate how the timing of changes to the contents of the input sequence affect the result sequence:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> ArraysAreBuffered()     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// A sneaky implementation may try to optimize for the case where the collection</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// implements IList or (even more &quot;reliable&quot;) is an array: it mustn&#39;t do this,</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// as otherwise the results can be tainted by side-effects within iteration</span>     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] source = { 0, 1, 2, 3 };     <br />    <br />&#160;&#160;&#160; <span class="Linq">var</span> query = source.Reverse();     <br />&#160;&#160;&#160; source[1] = 99; <span class="InlineComment">// This change *will* be seen due to deferred execution</span>     <br />&#160;&#160;&#160; <span class="Namespace">using</span> (<span class="Linq">var</span> iterator = query.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; iterator.MoveNext();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.AreEqual(3, iterator.Current);     <br />    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; source[2] = 100; <span class="InlineComment">// This change *won&#39;t* be seen&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span>    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; iterator.MoveNext();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.AreEqual(2, iterator.Current);     <br />    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; iterator.MoveNext();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.AreEqual(99, iterator.Current);     <br />    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; iterator.MoveNext();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Assert.AreEqual(0, iterator.Current);     <br />&#160;&#160;&#160; }     <br />} </div>  <p>If you can think of any potentially-surprising tests, I&#39;d be happy to implement them - there wasn&#39;t much I could think of in terms of corner cases.</p>  <h3>Let&#39;s implement it!</h3>  <p>Eager validation of source combined with deferred execution suggests the normal implementation of splitting the operator into two methods - I won&#39;t bother showing the public part, as it only does exactly what you&#39;d expect it to. However, to make up for the fact that Reverse is so simple, I&#39;ll present three implementations of the &quot;Impl&quot; method.</p>  <p>First, let&#39;s use a collection which performs the reversing for us automatically: a stack. The iterator returned by Stack&lt;T&gt; returns items in the order in which they would be seen by multiple calls to Pop - i.e. the reverse of the order in which they were added. This makes the implementation trivial:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; ReverseImpl&lt;TSource&gt;(IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; Stack&lt;TSource&gt; stack = <span class="Keyword">new</span> Stack&lt;TSource&gt;(source);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> stack)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> item;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Again, with &quot;yield foreach&quot; we could have done this in a single statement.</p>  <p>Next up, a linked list. In some ways, using a linked list is very natural - you never need to resize an array, or anything like that. On the other hand, we have an extra node object for every single element, which is a massive overhead. It&#39;s not what I&#39;d choose to use for production in this case, but it&#39;s worth showing:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; ReverseImpl&lt;TSource&gt;(IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; LinkedList&lt;TSource&gt; list = <span class="Keyword">new</span> LinkedList&lt;TSource&gt;(source);     <br />&#160;&#160;&#160; LinkedListNode&lt;TSource&gt; node = list.Last; <span class="InlineComment">// Property, not method!</span>     <br />&#160;&#160;&#160; <span class="Statement">while</span> (node != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> node.Value;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; node = node.Previous;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Finally, a more &quot;close to the metal&quot; approach using our existing ToBuffer method:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TSource&gt; ReverseImpl&lt;TSource&gt;(IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span> count;     <br />&#160;&#160;&#160; TSource[] array = source.ToBuffer(<span class="MethodParameter">out</span> count);     <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> i = count - 1; i &gt;= 0; i--)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> array[i];     <br />&#160;&#160;&#160; }     <br />} </div>  <p>This is probably not significantly more efficient than the version using Stack&lt;T&gt; - I expect Stack&lt;T&gt; has a similar implementation to ToBuffer when it&#39;s constructed with an input sequence. However, as it&#39;s so easy to count down from the end of the array to the start, we don&#39;t really need to take advantage of any of the features of Stack - so we might as well just use the array directly.</p>  <p>Note that this relies on the fact that ToBuffer will create a copy of whatever it&#39;s given, including an array. That&#39;s okay though - we&#39;re relying on that all over the place :)</p>  <h3>Conclusion</h3>  <p>It&#39;s hard to see how this could really be optimized any further, other than by improving ToBuffer based on usage data. Overall, a lovely simple operator.</p>  <p>It&#39;s probably about time I tackled some of the arithmetic aggregation operators... so next time I&#39;ll probably implement Sum.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
