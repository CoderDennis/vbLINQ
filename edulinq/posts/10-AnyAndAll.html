<html>
<head>
<title>Reimplementing LINQ to Objects: Part 10 - Any and All</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 10 - Any and All</h1>
<p>Another day, another blog post. I should emphasize that this rate of posting is likely to be short-lived... although if I get into the habit of writing a post on the morning commute when I go back to work after the Christmas holidays, I could keep ploughing through until we&#39;re done.</p>  <p>Anyway, today we have a pair of operators: Any and All.</p>  <h3>What are they?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.any.aspx" target="_blank">&quot;Any&quot;</a> has two overloads; there&#39;s only one for <a href="http://msdn.microsoft.com/en-us/library/bb548541.aspx" target="_blank">&quot;All&quot;</a>:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Any&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Any&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> All&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)</div>  <p>The names really are fairly self-explanatory:</p>  <ul>   <li>&quot;Any&quot; without a predicate returns whether there are <em>any</em> elements in the input sequence </li>    <li>&quot;Any&quot; with a predicate returns whether <em>any</em> elements in the input sequence match the predicate </li>    <li>&quot;All&quot; returns whether <em>all</em> the elements in the input sequence match the given predicate </li> </ul>  <p>Both operators use <em>immediate execution - </em>they don&#39;t return until they&#39;ve got the answer, basically.</p>  <p>Importantly, &quot;All&quot; has to read through the entire input sequence to return true, but can return as soon as it&#39;s found a non-matching element; &quot;Any&quot; can return true as soon as it&#39;s found a matching element, but has to iterate over the entire input sequence in order to return false. This gives rise to one very simple LINQ performance tip: it&#39;s almost never a good idea to use a query like</p>  <div class="code"><span class="InlineComment">// Don&#39;t use this</span>     <br /><span class="Statement">if</span> (query.Count() != 0)</div>  <p>That has to iterate over *all* the results in the query... when you really only care whether or not there are <em>any</em> results. So use &quot;Any&quot; instead:</p>  <div class="code"><span class="InlineComment">// Use this instead</span>     <br /><span class="Statement">if</span> (query.Any()) </div>  <p>If this is part of a bigger LINQ to SQL query, it may not make a difference - but in LINQ to Objects it can certainly be a huge boon.</p>  <p>Anyway, let&#39;s get on to testing the three methods...</p>  <h3>What are we going to test?</h3>  <p>Feeling virtuous tonight, I&#39;ve even tested argument validation again... although it&#39;s easy to get that right here, as we&#39;re using immediate execution.</p>  <p>Beyond that, I&#39;ve tested a few scenarios:</p>  <ul>   <li>An empty sequence will return false with Any, but true with All. (Whatever the predicate is for All, there are no elements which fail it.) </li>    <li>A sequence with any elements at all will make the predicate-less Any return true. </li>    <li>If all the elements <em>don&#39;t</em> match the predicate, both Any and All return false. </li>    <li>If <em>some</em> elements match the predicate, Any will return true but All will return false. </li>    <li>     <div align="left">If <em>all</em> elements match the predicate, All will return true.</div>   </li> </ul>  <p align="left">Those are all straightforward, so I won&#39;t give the code. One final test is interesting though: we prove that Any returns as soon as it&#39;s got the result by giving it a query which will throw an exception if it&#39;s iterated over completely. The easiest way of doing this is to start out with a sequence of integers including 0, and then use Select with a projection which divides some constant value by each element. In this test case, I&#39;ve given it a value which will match the predicate <em>before</em> the value which will cause the exception to be thrown:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> SequenceIsNotEvaluatedAfterFirstMatch()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] src = { 10, 2, 0, 3 };     <br />&#160;&#160;&#160; <span class="Linq">var</span> query = src.Select(x =&gt; 10 / x);     <br />&#160;&#160;&#160; <span class="InlineComment">// This will finish at the second element (x = 2, so 10/x = 5)</span>     <br />&#160;&#160;&#160; <span class="InlineComment">// It won&#39;t evaluate 10/0, which would throw an exception</span>     <br />&#160;&#160;&#160; Assert.IsTrue(query.Any(y =&gt; y &gt; 2));     <br />} </div>  <p>There&#39;s an equivalent test for All, where a <em>non-matching</em> element occurs before the exceptional one.</p>  <p>So, with all the tests written, let&#39;s get on with the interesting bit:</p>  <h3>Let&#39;s implement them!</h3>  <p>The first thing to note is that all of these <em>could</em> be implemented in terms of either Any-with-a-predicate or All. For example, given All, we could implement Any as:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Any&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.Any(x =&gt; <span class="Keyword">true</span>);     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Any&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (predicate == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span> !source.All(x =&gt; !predicate(x));     <br />} </div>  <p>It&#39;s simplest to implement the predicate-less Any in terms of the predicated one - using a predicate which returns true for any element means that Any will return true for <em>any</em> element at all, which is what we want.</p>  <p>The inversions in the call to All take a minute to get your head round, but it&#39;s basically <a href="http://en.wikipedia.org/wiki/De_Morgan&#39;s_laws" target="_blank">De Morgan&#39;s law</a> in LINQ form: we effectively invert the predicate to find out if all of the elements <em>don&#39;t</em> match the original predicate... then return the inverse. Due to the inversion, this still returns early in all the appropriate situations, too.</p>  <p>While we <em>could</em> do that, I&#39;ve actually preferred a straightforward implementation of all of the separate methods:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Any&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span class="Namespace">using</span> (IEnumerator&lt;TSource&gt; iterator = source.GetEnumerator())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> iterator.MoveNext();     <br />&#160;&#160;&#160; }     <br />}     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> Any&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (predicate == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">true</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />}     <br />    <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span>&#160;<span class="ValueType">bool</span> All&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Func&lt;TSource, <span class="ValueType">bool</span>&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">if</span> (predicate == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (!predicate(item))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">false</span>;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">true</span>;     <br />} </div>  <p>Aside from anything else, this makes it obvious where the &quot;early out&quot; comes in each case - and also means that any stack traces generated are rather easier to understand. It would be quite odd from a client developer&#39;s point of view to call Any but see All in the stack trace, or vice versa.</p>  <p>One interesting point to note is that I don&#39;t actually use a foreach loop in Any - although I could, of course. Instead, I just get the iterator and then return whether the very first call to MoveNext indicates that there are any elements. I like the fact that reading this method it&#39;s obvious (at least to me) that we really couldn&#39;t care less what the <em>value</em> of the first element is - because we never ask for it.</p>  <h3>Conclusion</h3>  <p>Probably the most important lesson here is the advice to use Any (without a predicate) instead of Count when you can. The rest was pretty simple - although it&#39;s always fun to see one operator implemented in terms of another.</p>  <p>So, what next? Possibly Single/SingleOrDefault/First/FirstOrDefault/Last/LastOrDefault. I might as well do them all together - partly as they&#39;re so similar, and partly to emphasize the differences which <em>do</em> exist.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
