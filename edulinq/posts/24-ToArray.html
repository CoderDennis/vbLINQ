<html>
<head>
<title>Reimplementing LINQ to Objects: Part 24 - ToArray</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 24 - ToArray</h1>
<p>This really <em>is</em> a simple one. So simple I might even find the energy to implement ToDictionary as well tonight... we&#39;ll see. (EDIT: Oops. It became slightly less simple in the end, as I came up with the third implementation. Oh well.)</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb298736.aspx">ToArray</a> is basically the equivalent of ToList, but producing an array instead of a list. It has a single signature:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource[] ToArray&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source) </div>  <p>Just to recap:</p>  <ul>   <li>It&#39;s another extension method, which is useful when we want to use type inference. </li>    <li>It uses immediate execution - nothing is deferred, and the entire sequence is read before the method completes. </li>    <li>It performs simple argument validation: source can&#39;t be null </li>    <li>It creates an independent but shallow copy of the collection (so any changes to the objects referenced by source will be visible in the result, but not changes to source itself - and vice versa) </li>    <li>It&#39;s optimized for ICollection&lt;T&gt;, although in a slightly different way to ToList. </li> </ul>  <h3>What are we going to test?</h3>  <p>Exactly the same as <a href="http://msmvps.com/blogs/jon_skeet/archive/2011/01/01/reimplementing-linq-to-objects-part-20-tolist.aspx">we did for ToList</a>, basically - with one bit of care required. In our test for the source and result being independent of each other, we can&#39;t just create a new variable of type List&lt;T&gt; and call ToArray on it - because that would call the implementation in List&lt;T&gt; itself. I reckoned the easiest way of making this clear was to call the method directly as a normal static method, instead of using it as an extension method:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> ResultIsIndependentOfSource()     <br />{     <br />&#160;&#160;&#160; List&lt;<span class="ReferenceType">string</span>&gt; source = <span class="Keyword">new</span> List&lt;<span class="ReferenceType">string</span>&gt; { <span class="String">&quot;xyz&quot;</span>, <span class="String">&quot;abc&quot;</span> };     <br />&#160;&#160;&#160; <span class="InlineComment">// Make it obvious we&#39;re not calling List&lt;T&gt;.ToArray</span>     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] result = Enumerable.ToArray(source);     <br />&#160;&#160;&#160; result.AssertSequenceEqual(<span class="String">&quot;xyz&quot;</span>, <span class="String">&quot;abc&quot;</span>);     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Change the source: result won&#39;t have changed</span>     <br />&#160;&#160;&#160; source[0] = <span class="String">&quot;xxx&quot;</span>;     <br />&#160;&#160;&#160; Assert.AreEqual(<span class="String">&quot;xyz&quot;</span>, result[0]);     <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// And the reverse</span>     <br />&#160;&#160;&#160; result[1] = <span class="String">&quot;yyy&quot;</span>;     <br />&#160;&#160;&#160; Assert.AreEqual(<span class="String">&quot;abc&quot;</span>, source[1]);     <br />} </div>  <p>One other interesting facet of the testing is that we can only <em>partially</em> test the optimization for ICollection&lt;T&gt;. We can make sure that it&#39;s optimized as far as not using the iterator (as per the previous test), but there&#39;s more optimization coming, and I haven&#39;t worked out how to test for that yet. You&#39;ll see what I mean when we come to implement it. Speaking of which...</p>  <h3>Let&#39;s implement it!</h3>  <p>We can make all our tests pass with a cheat: whatever the input type, convert it to a List&lt;T&gt; and then call ToArray on the result. Heck, if we call ToList to do the initial conversion, that will even do the argument validation for us and use the right parameter name in the exception:</p>  <div class="code"><span class="InlineComment">// Implementation by Mr Cheaty MacCheaterson</span>     <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource[] ToArray&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">return</span> source.ToList().ToArray();     <br />} </div>  <p>Now I&#39;m not averse to the general approach taken here - but there&#39;s actually a bit more optimization we can do.</p>  <p>Remember how ICollection&lt;T&gt; exposes Count and CopyTo, which the List&lt;T&gt; constructor uses when the input implements ICollection&lt;T&gt;? Well, that means that building a List&lt;T&gt; is relatively cheap for a collection - but calling ToArray on the list will still mean copying all the data out again (as List&lt;T&gt;.ToArray can&#39;t just return its own internal array - it has to create a copy). We can use exactly the same members ourselves, and avoid one level of copying:</p>  <div class="code"><span class="InlineComment">// Somewhat better... though still not quite ideal</span>     <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource[] ToArray&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)     <br />{     <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; ICollection&lt;TSource&gt; collection = source <span class="Keyword">as</span> ICollection&lt;TSource&gt;;     <br />&#160;&#160;&#160; <span class="Statement">if</span> (collection != <span class="Keyword">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource[] ret = <span class="Keyword">new</span> TSource[collection.Count];     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; collection.CopyTo(ret, 0);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> ret;     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">return</span>&#160;<span class="Keyword">new</span> List&lt;TSource&gt;(source).ToArray();     <br />} </div>  <p>That&#39;s pretty good now - except it still involves a copy from the List&lt;T&gt; into a new array every time. That&#39;s <em>almost always</em> appropriate, in fact... because unless the resulting list happened to expand its array to <em>exactly</em> the right size, we&#39;d need to make a copy anyway. After all, we can&#39;t return an array that&#39;s too big. However, we <em>can</em> optimize for the &quot;just the right size&quot; case if we basically implement List&lt;T&gt;&#39;s array expansion ourselves, leading to this:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> TSource[] ToArray&lt;TSource&gt;(<span class="Keyword">this</span> IEnumerable&lt;TSource&gt; source)    <br />{    <br />&#160;&#160;&#160; <span class="Statement">if</span> (source == <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">throw</span>&#160;<span class="Keyword">new</span> ArgumentNullException(<span class="String">&quot;source&quot;</span>);    <br />&#160;&#160;&#160; }    <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Optimize for ICollection&lt;T&gt;</span>    <br />&#160;&#160;&#160; ICollection&lt;TSource&gt; collection = source <span class="Keyword">as</span> ICollection&lt;TSource&gt;;    <br />&#160;&#160;&#160; <span class="Statement">if</span> (collection != <span class="Keyword">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource[] tmp = <span class="Keyword">new</span> TSource[collection.Count];    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; collection.CopyTo(tmp, 0);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> tmp;    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span class="InlineComment">// We&#39;ll have to loop through, creating and copying arrays as we go</span>    <br />&#160;&#160;&#160; TSource[] ret = <span class="Keyword">new</span> TSource[16];    <br />&#160;&#160;&#160; <span class="ValueType">int</span> count = 0;    <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TSource item <span class="Statement">in</span> source)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="InlineComment">// Need to expand...</span>    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (count == ret.Length)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Array.Resize(<span class="MethodParameter">ref</span> ret, ret.Length * 2);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ret[count++] = item;    <br />&#160;&#160;&#160; }    <br />    <br />&#160;&#160;&#160; <span class="InlineComment">// Now create another copy if we have to, in order to get an array of the</span>    <br />&#160;&#160;&#160; <span class="InlineComment">// right size</span>    <br />&#160;&#160;&#160; <span class="Statement">if</span> (count != ret.Length)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Array.Resize(<span class="MethodParameter">ref</span> ret, count);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span class="Statement">return</span> ret;    <br />} </div>  <p>Is this level of optimization worth it? Probably not. I picked the starting size of 16 out of thin air (or dimly recalled initial counts for some collection or other - possibly Java&#39;s ArrayList&lt;T&gt;). Maybe we should triple the capacity rather than double it, just for laughs. It&#39;s all guesswork, really. The middle implementation feels like a more appropriate one to me, but with an obvious optimization just itching to be implemented, I thought I might as well provide the code. It&#39;s reasonably obviously correct, but it&#39;s just a bit longwinded for the marginal benefit over our second attempt.</p>  <p>It&#39;s even more annoying that I can&#39;t think of a way to test this easily - I could <em>benchmark</em> it of course, but that&#39;s not the same as unit testing it... I can&#39;t easily <em>prove</em> that we&#39;re optimizing either the ICollection&lt;T&gt; or &quot;correct guess at size&quot; cases.</p>  <h3>Conclusion</h3>  <p>It&#39;s always interesting to see what else springs to mind when I&#39;m writing up the operator as opposed to just implementing it in Visual Studio. I&#39;d got as far as the second implementation but not the third when I started this post.</p>  <p>It&#39;s possible that in the end, the 4-overload ToDictionary operator will actually end up being simpler than ToArray. Who&#39;d have thought?</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
