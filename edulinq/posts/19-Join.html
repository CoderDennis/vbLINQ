<html>
<head>
<title>Reimplementing LINQ to Objects: Part 19 - Join</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 19 - Join</h1>
<p>You might expect that as joining is such a fundamental concept in SQL, it would be a complex operation to both describe and implement in LINQ. Fortunately, nothing could be further from the truth...</p>  <h3>What is it?</h3>  <p><a href="http://msdn.microsoft.com/en-us/library/bb344797.aspx" target="_blank">Join</a> has a mere two overloads, with the familiar pattern of one taking a custom equality comparer and the other not:</p>  <div class="code"><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TOuter&gt; outer,     <br />&#160;&#160;&#160; IEnumerable&lt;TInner&gt; inner,     <br />&#160;&#160;&#160; Func&lt;TOuter, TKey&gt; outerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TInner, TKey&gt; innerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TOuter, TInner, TResult&gt; resultSelector)     <br />    <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TOuter&gt; outer,     <br />&#160;&#160;&#160; IEnumerable&lt;TInner&gt; inner,     <br />&#160;&#160;&#160; Func&lt;TOuter, TKey&gt; outerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TInner, TKey&gt; innerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TOuter, TInner, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer) </div>  <p>These are daunting signatures to start with - four type parameters, and up to six normal method parameters (including the first &quot;this&quot; parameter indicating an extension method). <em>Don&#39;t panic</em>. It&#39;s actually quite simple to understand each individual bit:</p>  <ul>   <li>We have two sequences (outer and inner). The two sequences can have different element types (TOuter and TInner). </li>    <li>For each sequence, there&#39;s also a <em>key selector</em> - a projection from a single item to the key for that item. Note that although the key type can be different from the two sequence types, there&#39;s only <em>one</em> key type - both key selectors have to return the same kind of key (TKey). </li>    <li>An optional equality comparer is used to compare keys. </li>    <li>A delegate (resultSelector) is used to project a pair of items whose keys are equal (one from each sequence) to the result type (TResult) </li> </ul>  <p>The idea is that we look through the two input sequences for pairs which correspond to equal keys, and yield one output element for each pair. This is an <em>equijoin</em> operation: we can only deal with <em>equal</em> keys, not pairs of keys which meet some arbitrary condition. It&#39;s also an <em>inner join</em> in database terms - we will only see an item from one sequence if there&#39;s a &quot;matching&quot; item from the other sequence. I&#39;ll talk about mimicking <em>left joins</em> when I implement GroupJoin.</p>  <p>The documentation gives us details of the order in which we need to return items:</p>  <blockquote>   <p>Join preserves the order of the elements of outer, and for each of these elements, the order of the matching elements of inner.</p> </blockquote>  <p>For the sake of clarity, it&#39;s probably worth including a naive implementation which at least gives the right results in the right order:</p>  <div class="code"><span class="InlineComment">// Bad implementation, only provided for the purposes of discussion</span>     <br /><span class="Modifier">public</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(     <br />&#160;&#160;&#160; <span class="Keyword">this</span> IEnumerable&lt;TOuter&gt; outer,     <br />&#160;&#160;&#160; IEnumerable&lt;TInner&gt; inner,     <br />&#160;&#160;&#160; Func&lt;TOuter, TKey&gt; outerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TInner, TKey&gt; innerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TOuter, TInner, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="InlineComment">// Argument validation omitted</span>     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (TOuter outerElement <span class="Statement">in</span> outer)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TKey outerKey = outerKeySelector(outerElement);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (TInner innerElement <span class="Statement">in</span> inner)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TKey innerKey = innerKeySelector(innerElement);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">if</span> (comparer.Equals(outerKey, innerKey))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> resultSelector(outerElement, innerElement);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Aside from the missing argument validation, there are two important problems with this:</p>  <ul>   <li>It iterates over the inner sequence multiple times. I always advise anyone implementing a LINQ-like operator to only iterate over any input sequence once. There are sequences which are impossible to iterate over multiple times, or which may give different results each time. That&#39;s bad news. </li>    <li>It always has a complexity of O(N * M) for N items in the inner sequence and M items in the outer sequence. Eek. Admittedly that&#39;s always a possible complexity - two sequences which have the same key for all elements will <em>always</em> have that complexity - but in a typical situation we can do considerably better. </li> </ul>  <p>The real Join operator uses the same behaviour as Except and Intersect when it comes to how the input sequences are consumed:</p>  <ul>   <li>Argument validation occurs eagerly - both sequences and all the &quot;selector&quot; delegates have to be non-null; the comparer argument can be null, leading to the default equality comparer for TKey being used. </li>    <li>The overall operation uses deferred execution: it doesn&#39;t iterate over either input sequence until something starts iterating over the result sequence. </li>    <li>When MoveNext is called on the result sequence for the first time, it immediately consumes the <em>whole</em> of the inner sequence, buffering it. </li>    <li>The outer sequence is streamed - it&#39;s only read one element at a time. By the time the result sequence has started yielding results from the second element of outer, it&#39;s forgotten about the first element. </li> </ul>  <p>We&#39;ve started veering towards an implementation already, so let&#39;s think about tests.</p>  <h3>What are we going to test?</h3>  <p>I haven&#39;t bothered with argument validation tests this time - even with cut and paste, the 10 tests required to completely check everything feels like overkill.</p>  <p>However, I have tested:</p>  <ul>   <li>Joining two invalid sequences, but not using the results (i.e. testing deferred execution) </li>    <li>The way that the two sequences are consumed </li>    <li>Using a custom comparer </li>    <li>Not specifying a comparer </li>    <li>Using sequences of different types </li> </ul>  <p>See the source code for more details, but here&#39;s a flavour - the final test:</p>  <div class="code">[Test]    <br /><span class="Modifier">public</span>&#160;<span class="ValueType">void</span> DifferentSourceTypes()     <br />{     <br />&#160;&#160;&#160; <span class="ValueType">int</span>[] outer = { 5, 3, 7 };     <br />&#160;&#160;&#160; <span class="ReferenceType">string</span>[] inner = { <span class="String">&quot;bee&quot;</span>, <span class="String">&quot;giraffe&quot;</span>, <span class="String">&quot;tiger&quot;</span>, <span class="String">&quot;badger&quot;</span>, <span class="String">&quot;ox&quot;</span>, <span class="String">&quot;cat&quot;</span>, <span class="String">&quot;dog&quot;</span> };     <br />    <br />&#160;&#160;&#160; <span class="Linq">var</span> query = outer.Join(inner,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; outerElement =&gt; outerElement,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; innerElement =&gt; innerElement.Length,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (outerElement, innerElement) =&gt; outerElement + <span class="String">&quot;:&quot;</span> + innerElement);     <br />&#160;&#160;&#160; query.AssertSequenceEqual(<span class="String">&quot;5:tiger&quot;</span>, <span class="String">&quot;3:bee&quot;</span>, <span class="String">&quot;3:cat&quot;</span>, <span class="String">&quot;3:dog&quot;</span>, <span class="String">&quot;7:giraffe&quot;</span>);     <br />} </div>  <p>To be honest, the tests aren&#39;t very exciting. The implementation is remarkably simple though.</p>  <h3>Let&#39;s implement it!</h3>  <p>Trivial decision 1: make the comparer-less overload call the one with the comparer.</p>  <p>Trivial decision 2: use the split-method technique to validate arguments eagerly but defer the rest of the operation</p>  <p>That leaves us with the actual implementation in an iterator block, which is all I&#39;m going to provide the code for here. So, what are we going to do?</p>  <p>Well, we know that we&#39;re going to have to read in the whole of the &quot;inner&quot; sequence - but let&#39;s wait a minute before deciding how to store it. We&#39;re then going to iterate over the &quot;outer&quot; sequence. For each item in the outer sequence, we need to find the key and then work out all the &quot;inner&quot; sequence items which match that key. Now, the idea of finding all the items in a sequence which match a particular key should sound familiar to you - that&#39;s exactly what a lookup is for. If we build a lookup from the inner sequence as our very first step, the rest becomes easy: we can fetch the sequence of matches, then iterate over them and yield the return value of calling result selector on the pair of elements.</p>  <p>All of this is easier to see in code than in words, so here&#39;s the method:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; JoinImpl&lt;TOuter, TInner, TKey, TResult&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TOuter&gt; outer,     <br />&#160;&#160;&#160; IEnumerable&lt;TInner&gt; inner,     <br />&#160;&#160;&#160; Func&lt;TOuter, TKey&gt; outerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TInner, TKey&gt; innerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TOuter, TInner, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> lookup = inner.ToLookup(innerKeySelector, comparer);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="Linq">var</span> outerElement <span class="Statement">in</span> outer)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">var</span> key = outerKeySelector(outerElement);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="Linq">var</span> innerElement <span class="Statement">in</span> lookup[key])     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> resultSelector(outerElement, innerElement);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Personally, I think this is rather beautiful... in particular, I like the way that it uses every parameter exactly once. Everything is just set up to work nicely.</p>  <p>But wait, there&#39;s more... If you look at the nested foreach loops, that should remind you of something: for each outer sequence element, we&#39;re computing a nested sequence, then applying a delegate to each pair, and yielding the result. That&#39;s almost exactly the definition of SelectMany! If only we had a &quot;yield foreach&quot; or &quot;yield!&quot; I&#39;d be tempted to use an implementation like this:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; JoinImpl&lt;TOuter, TInner, TKey, TResult&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TOuter&gt; outer,     <br />&#160;&#160;&#160; IEnumerable&lt;TInner&gt; inner,     <br />&#160;&#160;&#160; Func&lt;TOuter, TKey&gt; outerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TInner, TKey&gt; innerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TOuter, TInner, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> lookup = inner.ToLookup(innerKeySelector, comparer);     <br />&#160;&#160;&#160; <span class="InlineComment">// Warning: not really valid C#</span>     <br />&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">foreach</span> outer.SelectMany(outerElement =&gt; lookup[outerKeySelector(outerElement)],     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; resultSelector);     <br />} </div>  <p>Unfortunately there&#39;s no such thing as a &quot;yield foreach&quot; statement. We can&#39;t just call SelectMany and return the result directly, because then we wouldn&#39;t be deferring execution. The best we can sensibly do is loop:</p>  <div class="code"><span class="Modifier">private</span>&#160;<span class="Modifier">static</span> IEnumerable&lt;TResult&gt; JoinImpl&lt;TOuter, TInner, TKey, TResult&gt;(     <br />&#160;&#160;&#160; IEnumerable&lt;TOuter&gt; outer,     <br />&#160;&#160;&#160; IEnumerable&lt;TInner&gt; inner,     <br />&#160;&#160;&#160; Func&lt;TOuter, TKey&gt; outerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TInner, TKey&gt; innerKeySelector,     <br />&#160;&#160;&#160; Func&lt;TOuter, TInner, TResult&gt; resultSelector,     <br />&#160;&#160;&#160; IEqualityComparer&lt;TKey&gt; comparer)     <br />{     <br />&#160;&#160;&#160; <span class="Linq">var</span> lookup = inner.ToLookup(innerKeySelector, comparer);     <br />&#160;&#160;&#160; <span class="Linq">var</span> results = outer.SelectMany(outerElement =&gt; lookup[outerKeySelector(outerElement)],     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; resultSelector);     <br />&#160;&#160;&#160; <span class="Statement">foreach</span> (<span class="Linq">var</span> result <span class="Statement">in</span> results)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> result;     <br />&#160;&#160;&#160; }     <br />} </div>  <p>At that stage, I think I prefer the original form - which is still pretty simple, thanks to the lookup.</p>  <p>While I have avoided using other operators for implementations in the past, in this case it feels so completely natural, it would be silly <em>not</em> to use ToLookup to implement Join.</p>  <p>One final point before I wrap up for the night...</p>  <h3>Query expressions</h3>  <p>Most of the operators I&#39;ve been implementing recently don&#39;t have any direct mapping in C# query expressions. Join does, however. The final test I showed before can also be written like this:</p>  <div class="code"><span class="ValueType">int</span>[] outer = { 5, 3, 7 };     <br /><span class="ReferenceType">string</span>[] inner = { <span class="String">&quot;bee&quot;</span>, <span class="String">&quot;giraffe&quot;</span>, <span class="String">&quot;tiger&quot;</span>, <span class="String">&quot;badger&quot;</span>, <span class="String">&quot;ox&quot;</span>, <span class="String">&quot;cat&quot;</span>, <span class="String">&quot;dog&quot;</span> };     <br />    <br /><span class="Linq">var</span> query = <span class="Linq">from</span> x <span class="Statement">in</span> outer     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">join</span> y <span class="Statement">in</span> inner <span class="Linq">on</span> x <span class="Linq">equals</span> y.Length     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> x + <span class="String">&quot;:&quot;</span> + y;     <br />    <br />query.AssertSequenceEqual(<span class="String">&quot;5:tiger&quot;</span>, <span class="String">&quot;3:bee&quot;</span>, <span class="String">&quot;3:cat&quot;</span>, <span class="String">&quot;3:dog&quot;</span>, <span class="String">&quot;7:giraffe&quot;</span>); </div>  <p>The compiler will effectively generate the same code (although admittedly I&#39;ve used shorter range variable names here - x and y instead of outerElement and innerElement respectively). In this case the resultSelector delegate it supplies is simply the final projection from the &quot;select&quot; clause - but if we had anything else (such as a where clause) between the join and the select, the compiler would introduce a <em>transparent identifier</em> to propagate the values of both x and y through the query. It looks like I haven&#39;t blogged explicitly about transparent identifiers, although I cover them in C# in Depth. Maybe once I&#39;ve finished actually <em>implementing</em> the operators, I&#39;ll have a few more general posts on this sort of thing.</p>  <p>Anyway, the point is that for simple join clauses (as opposed to join...into) we&#39;ve implemented everything we need to. Hoorah.</p>  <h3>Conclusion</h3>  <p>I spoiled some of the surprise around how easy Join would be to implement by mentioning it in the ToLookup post, but I&#39;m still impressed by how neat it is. Again I should emphasize that this is due to the design of LINQ - it&#39;s got nothing to do with my own prowess.</p>  <p>This won&#39;t be the end of our use of lookups though... the other grouping constructs can all use them too. I&#39;ll try to get them all out of the way before moving on to operators which feel a bit different...</p>  <h3>Addendum</h3>  <p>It turns out this wasn&#39;t quite as simple as I&#39;d expected. Although ToLookup and GroupBy handle null keys without blinking, Join and GroupJoin <em>ignore</em> them. I had to write an alternative version of ToLookup which ignores null keys while populating the lookup, and then replace the calls of &quot;ToLookup&quot; in the code above with calls to &quot;ToLookupNoNullKeys&quot;. This isn&#39;t documented anywhere, and is inconsistent with ToLookup/GroupBy. I&#39;ve opened up a <a href="https://connect.microsoft.com/VisualStudio/feedback/details/639943">Connect issue</a> about it, in the hope that it at least gets documented properly. (It&#39;s too late to change the behaviour now, I suspect.)</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
