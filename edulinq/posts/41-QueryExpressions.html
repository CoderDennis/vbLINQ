<html>
<head>
<title>Reimplementing LINQ to Objects: Part 41 - How query expressions work</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 41 - How query expressions work</h1>
<p>Okay, first a quick plug. This <em>won&#39;t</em> be in as much detail as chapter 11 of <a href="http://manning.com/skeet2/">C# in Depth</a>. If you want more, buy a copy. (Until Feb 1st, there&#39;s 43% off it if you buy it from Manning with coupon code j2543.) Admittedly that chapter has to <em>also</em> explain all the basic operators rather than just query expression translations, but that&#39;s a fair chunk of it.</p>  <p>If you&#39;re already familiar with query expressions, don&#39;t expect to discover anything particularly insightful here. However, you might be interested in the cheat sheet at the end, in case you forget some of the syntax occasionally. (I know I do.)</p>  <h3>What is this &quot;query expression&quot; of which you speak?</h3>  <p>Query expressions are a little nugget of goodness hidden away in section 7.16 of the <a href="http://csharpindepth.com/Articles/Chapter1/Specifications.aspx">C# specification</a>. Unlike some language features like generics and dynamic typing, query expressions keep themselves to themselves, and don&#39;t impinge on the rest of the spec. A query expression is a bit of C# which looks a bit like a mangled version of SQL. For example:</p>  <div class="code"><span class="Linq">from</span> person <span class="Statement">in</span> people     <br /><span class="Linq">where</span> person.FirstName.StartsWith(<span class="String">&quot;J&quot;</span>)     <br /><span class="Linq">orderby</span> person.Age     <br /><span class="Linq">select</span> person.LastName </div>  <p>It looks somewhat unlike the rest of C#, which is both a blessing and a curse. On the one hand, queries stand out so it&#39;s easy to see they&#39;re queries. On the other hand... they stand out rather than fitting in with the rest of your code. To be honest I haven&#39;t found this to be an issue, but it can take a little getting used to.</p>  <p>Every query expression can be represented in C# code, but the reverse isn&#39;t true. Query expressions only take in a subset of the standard query operators - and only a limited set of the overloads, at that. It&#39;s not unusual to see a query expression followed by a &quot;normal&quot; query operator call, for example:</p>  <div class="code"><span class="Linq">var</span> list = (<span class="Linq">from</span> person <span class="Statement">in</span> people     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">where</span> person.FirstName.StartsWith(<span class="String">&quot;J&quot;</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">orderby</span> person.Age     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> person.LastName)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .ToList(); </div>  <p>So, that&#39;s very roughly what they look like. That&#39;s the sort of thing I&#39;m dealing with in this post. Let&#39;s start dissecting them.</p>  <h3>Compiler translations</h3>  <p>First it&#39;s worth introducing the general principle of query expressions: they effectively get translated step by step into C# which eventually <em>doesn&#39;t</em> contain any query expressions. To stick with our first example, that ends up be translated into this code:</p>  <div class="code">people.Where(person =&gt; person.FirstName.StartsWith(<span class="String">&quot;J&quot;</span>))     <br />&#160;&#160;&#160;&#160;&#160; .OrderBy(person =&gt; person.Age)     <br />&#160;&#160;&#160;&#160;&#160; .Select(person =&gt; person.LastName) </div>  <p>It&#39;s important to understand that the compiler hasn&#39;t done anything apart from systematic translation to get to this point. In particular, so far we haven&#39;t depended on what &quot;people&quot; is, nor &quot;Where&quot;, &quot;OrderBy&quot; or &quot;Select&quot;.</p>  <p>Can you tell what this code does yet? You can probably hazard a pretty good guess, but you can&#39;t tell. Is it going to call Edulinq.Enumerable.Select, or System.Linq.Enumerable.Select, or something entirely different? It depends on the context. Heck, &quot;people&quot; could be the name of a type which has a static Where method. Or maybe it could be a reference to a class which has an <em>instance</em> method called Where... the options are open.</p>  <p>Of course, they don&#39;t stay open for long: the compiler takes that expression and compiles it applying all the normal rules. It converts the lambda expression into either a delegate or an expression tree, tries to resolve Where, OrderBy and Select as normal, and life continues. (Don&#39;t worry if you&#39;re not sure about expression trees yet - I&#39;ll come to them in another post.)</p>  <p>The important point is that the query expression translations don&#39;t know about System.Linq. The spec barely mentioned IEnumerable&lt;T&gt;, and certainly doesn&#39;t rely on it. The whole thing is <em>pattern based</em>. If you have an API which provides some or all of the operators used by the pattern, in an appropriate way, you can use query expressions with it. That&#39;s the secret sauce that allows you to use the same syntax for LINQ to Objects, LINQ to SQL, LINQ to Entities, Reactive Extensions, Parallel Extensions and more.</p>  <h3>Range variables and the initial &quot;from&quot; clause</h3>  <p>The first part of the query to look at is the first &quot;from&quot; clause, at the start of the query. It&#39;s worth mentioning upfront that this is handled somewhat differently to any <em>later</em> &quot;from&quot; clauses - I&#39;ll explain how they&#39;re translated later.</p>  <p>So we have an expression of the form:</p>  <div class="code">from <em>[type]</em> <em>identifier</em> in <em>expression</em></div>  <p>The &quot;expression&quot; part is just any expression. In most cases there <em>isn&#39;t</em> a type specified, in which case the translated version is simply the expression, but with the compiler remembering the identifier as a <em>range variable</em>. I&#39;ll do my best to explain what range variables are in a minute :)</p>  <p>If there <em>is</em> a type specified, that represents a call to Cast&lt;<em>type</em>&gt;(). So examples of the two translations so far are:</p>  <div class="code"><span class="InlineComment">// Query (incomplete)</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> people     <br />    <br /><span class="InlineComment">// Translation (+ range variable of &quot;x&quot;)</span>     <br />people     <br />    <br />    <br /><span class="InlineComment">// Query (incomplete)</span>     <br /><span class="Linq">from</span> Person x <span class="Statement">in</span> people     <br />    <br /><span class="InlineComment">// Translation (+ range variable of &quot;x&quot;)</span>     <br />(people).Cast&lt;Person&gt;() </div>  <p>These aren&#39;t complete query expressions - queries have very precise rules about how they can start and end. They <em>always</em> start with a &quot;from&quot; clause like this, and always end either with a &quot;group by&quot; clause or a &quot;select&quot; clause.</p>  <p>So what&#39;s the point of the range variable? Well, that&#39;s what gets used as the name of the lambda expression parameter used in all the later clauses. Let&#39;s add a select clause to create a complete expression and demonstrate how the variable could be used.</p>  <h3>A &quot;select&quot; clause</h3>  <p>A select clause is usually translated into a call to Select, using the &quot;body&quot; of the clause as the body of the lambda expression... and the range variable as the parameter. So to expand our previous query, we might have this translation:</p>  <div class="code"><span class="InlineComment">// Query</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> people     <br /><span class="Linq">select</span> x.Name     <br />    <br /><span class="InlineComment">// Translation</span>     <br />people.Select(x =&gt; x.Name) </div>  <p>That&#39;s all that range variables are used for: to provide placeholders within lambda expressions, effectively. They&#39;re quite unlike normal variables in most senses. It only makes sense to talk about the &quot;value&quot; of a range variable within a particular clause at a particular point in time when the clause is executing, for one particular value. Their nearest conceptual neighbour is probably the iteration variable declared in a foreach statement, but even that&#39;s not really the same - particularly given the way <a href="http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx">iteration variables are captured</a>, often to the surprise of developers.</p>  <p>The body part has to be a single <em>expression</em> - you can&#39;t use &quot;statement lambdas&quot; in query expressions. For example, there&#39;s no query expression which would translate to this:</p>  <div class="code"><span class="InlineComment">// Can&#39;t express this in a query expression</span>     <br />people.Select(x =&gt; {&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(<span class="String">&quot;Got &quot;</span> + x);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">return</span> x.Name;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }) </div>  <p>That&#39;s a perfectly valid C# expression, it&#39;s just there&#39;s now way of expressing it directly as a query expression.</p>  <p>I mentioned that a select clause <em>usually</em> translates into a Select call. There are two cases where it doesn&#39;t:</p>  <ul>   <li>If it&#39;s the sole clause after a secondary &quot;from&quot; clause, or a &quot;group by&quot;, &quot;join&quot; or &quot;join ... into&quot; clause, the body is used in the translation of that clause </li>    <li>If it&#39;s an &quot;identity&quot; projection coming after another clause, it&#39;s removed entirely. </li> </ul>  <p>I&#39;ll deal with the first point when we reach the relevant clauses. The second point leads to these translations:</p>  <div class="code"><span class="InlineComment">// Query</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> people     <br /><span class="Linq">where</span> x.IsAdult     <br /><span class="Linq">select</span> x     <br />    <br /><span class="InlineComment">// Translation: Select is removed</span>     <br />people.Where(x =&gt; x.IsAdult)     <br />    <br />    <br /><span class="InlineComment">// Query</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> people     <br /><span class="Linq">select</span> x     <br />    <br /><span class="InlineComment">// Translation: Select is *not* removed</span>     <br />people.Select(x =&gt; x) </div>  <p>The point of including the &quot;pointless&quot; select in the second translation is to hide the original source sequence; it&#39;s assumed that there&#39;s no need to do this in the first translation as the &quot;Where&quot; call will already have protected the source sufficiently.</p>  <h3>The &quot;where&quot; clause</h3>  <p>This one&#39;s really simple - especially as we&#39;ve already seen it! A where clause always just translates into a Where call. Sample translation, this time with no funny business removing degenerate query expressions:</p>  <div class="code"><span class="InlineComment">// Query</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> people     <br /><span class="Linq">where</span> x.IsAdult     <br /><span class="Linq">select</span> x.Name     <br />    <br /><span class="InlineComment">// Translation</span>     <br />people.Where(x =&gt; x.IsAdult)     <br />&#160;&#160;&#160;&#160;&#160; .Select(x =&gt; x.Name) </div>  <p>Note how the range variable is propagated through the query.</p>  <h3>The &quot;orderby&quot; clause</h3>  <p>Here&#39;s a secret: I can never remember offhand whether it&#39;s &quot;orderby&quot; or &quot;order by&quot; - it&#39;s confusing because it really is &quot;group by&quot;, but &quot;orderby&quot; is actually just a single word. Of course, Visual Studio gives a pretty unsubtle hint in terms of colouring.</p>  <p>In the simplest form, an orderby clause might look like this:</p>  <div class="code"><span class="InlineComment">// Query</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> people     <br /><span class="Linq">orderby</span> x.Age     <br /><span class="Linq">select</span> x.Name     <br />    <br /><span class="InlineComment">// Translation</span>     <br />people.OrderBy(x =&gt; x.Age)     <br />&#160;&#160;&#160;&#160;&#160; .Select(x =&gt; x.Name) </div>  <p>There are two things which can add complexity though:</p>  <ul>   <li>You can order by multiple expressions, separating them by commas </li>    <li>Each expression can be ordered ascending implicitly, ascending <em>explicitly</em> or descending explicitly. </li> </ul>  <p>The first sort expression is always translated into OrderBy or OrderByDescending; subsequent ones always become ThenBy or ThenByDescending. It makes no difference whether you explicitly specify &quot;ascending&quot; or not - I&#39;ve very rarely seen it in real queries. Here&#39;s an example putting it all together:</p>  <div class="code"><span class="InlineComment">// Query</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> people     <br /><span class="Linq">orderby</span> x.Age, x.FirstName <span class="Linq">descending</span>, x.LastName <span class="Linq">ascending</span>     <br /><span class="Linq">select</span> x.LastName     <br />    <br /><span class="InlineComment">// Translation</span>     <br />people.OrderBy(x =&gt; x.Age)     <br />&#160;&#160;&#160;&#160;&#160; .ThenByDescending(x =&gt; x.FirstName)     <br />&#160;&#160;&#160;&#160;&#160; .ThenBy(x =&gt; x.LastName)     <br />&#160;&#160;&#160;&#160;&#160; .Select(x =&gt; x.LastName) </div>  <p>Top tip: don&#39;t use multiple &quot;orderby&quot; clauses consecutively. This query is almost certainly <em>not</em> what you want:</p>  <div class="code"><span class="InlineComment">// Don&#39;t do this!      <br /></span><span class="Linq">from</span> x <span class="Statement">in</span> people&#160; <br /><span class="Linq">orderby</span> x.Age     <br /><span class="Linq">orderby</span> x.FirstName     <br /><span class="Linq">select</span> x.LastName </div>  <p>That will end up sorting by FirstName and <em>then</em> Age, and doing so rather slowly as it has to sort twice.</p>  <h3>The &quot;group by&quot; clause</h3>  <p>Grouping is another alternative to &quot;select&quot; as the final clause in a query. There are two expressions involved: the element selector (what you want to get in each group) and the key selector (how you want the groups to be organized). Unsurprisingly, this uses the GroupBy operator. So you might have a query to group people in families by their last name, with each group containing the first names of the family members:</p>  <div class="code"><span class="InlineComment">// Query expression</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> people&#160; <br /><span class="Linq">group</span> x.FirstName <span class="Linq">by</span> x.LastName     <br />    <br /><span class="InlineComment">// Translation</span>     <br />people.GroupBy(x =&gt; x.LastName, x =&gt; x.FirstName) </div>  <p>If the element selector is trivial, it isn&#39;t specified as part of the translation:</p>  <div class="code"><span class="InlineComment">// Query expression</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> people&#160; <br /><span class="Linq">group</span> x <span class="Linq">by</span> x.LastName     <br />    <br /><span class="InlineComment">// Translation</span>     <br />people.GroupBy(x =&gt; x.LastName) </div>  <h3>Query continuations</h3>  <p>Both &quot;select&quot; and &quot;group by&quot; can be followed by &quot;into <em>identifier</em>&quot;. This is known as a <em>query continuation</em>, and it&#39;s really simple. Its translation in the specification isn&#39;t in terms of a method call, but instead it transforms one query expression into another, effectively nesting one query as the source of another. I find that translation tricky to think about, personally... I prefer to think of it as using a temporary variable, like this:</p>  <div class="code"><span class="InlineComment">// Original query</span>     <br /><span class="Linq">var</span> query = <span class="Linq">from</span> x <span class="Statement">in</span> people     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> x.Name <span class="Linq">into</span> y     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">orderby</span> y.Length     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> y[0];     <br />    <br /><span class="InlineComment">// Query continuation translation</span>     <br /><span class="Linq">var</span> tmp = <span class="Linq">from</span> x <span class="Statement">in</span> people     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> x.Name;     <br />    <br /><span class="Linq">var</span> query = <span class="Linq">from</span> y <span class="Statement">in</span> tmp     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">orderby</span> y.Length     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Linq">select</span> y[0];     <br />    <br /><span class="InlineComment">// Final translation into methods</span>     <br /><span class="Linq">var</span> query = people.Select(x =&gt; x.Name)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .OrderBy(y =&gt; y.Length)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(y =&gt; y[0]); </div>  <p>Obviously that final translation <em>could</em> have been expressed in terms of two statements as well... they&#39;d be equivalent. This is why it&#39;s important that LINQ uses deferred execution - you can split up a query as much as you like, and it won&#39;t alter the execution flow. The query wouldn&#39;t actually <em>execute</em> when the value is assigned to &quot;tmp&quot; - it&#39;s just <em>preparing</em> the query for execution.</p>  <h3>Transparent identifiers and the &quot;let&quot; clause</h3>  <p>The rest of the query expression clauses all introduce an extra range variable in some form or other. This is the part of query expression translation which is hardest to understand, because it affects how any usage of the range variable in the query expression is translated.</p>  <p>We&#39;ll start with probably the simplest of the remaining clauses: the &quot;let&quot; clause. This simply introduces a new range variable based upon a projection. It&#39;s a bit like a &quot;select&quot;, but after a &quot;let&quot; clause both the original range variable <em>and</em> the new one are in scope for the rest of the query. They&#39;re typically used to avoid redundant computations, or simply to make the code simpler to read. For example, suppose computing an employee&#39;s tax is a complicated operation, and we want to display a list of employees and the tax they pay, with the higher tax-payer first:</p>  <div class="code"><span class="Linq">from</span> x <span class="Statement">in</span> employees     <br /><span class="Linq">let</span> tax = x.ComputeTax()     <br /><span class="Linq">orderby</span> tax <span class="Linq">descending</span>     <br /><span class="Linq">select</span> x.LastName + <span class="String">&quot;: &quot;</span> + tax </div>  <p>That&#39;s pretty readable, and we&#39;ve managed to avoid computing the tax twice (once for sorting and once for display).</p>  <p>The problem is, both &quot;x&quot; and &quot;tax&quot; are in scope at the same time... so what are we going to pass to the Select method at the end? We need one entity to pass through our query, which knows the value of both &quot;x&quot; and &quot;tax&quot; at any point (after the &quot;let&quot; clause, obviously). This is precisely the point of a transparent identifier. You can think of the above query as being translated into this:</p>  <div class="code"><span class="InlineComment">// Translation from &quot;let&quot; clause to another query expression</span>     <br /><span class="Linq">from</span> x <span class="Statement">in</span> employees     <br /><span class="Linq">select</span>&#160;<span class="Keyword">new</span> { x, tax = x.ComputeTax() } <span class="Linq">into</span> z     <br /><span class="Linq">orderby</span> z.tax <span class="Linq">descending</span>     <br /><span class="Linq">select</span> z.x.LastName + <span class="String">&quot;: &quot;</span> + z.tax     <br />    <br /><span class="InlineComment">// Final translated query</span>     <br />employees.Select(x =&gt; <span class="Keyword">new</span> { x, tax = x.ComputeTax() })     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .OrderByDescending(z =&gt; z.tax)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(z =&gt; z.x.LastName + <span class="String">&quot;: &quot;</span> + z.tax) </div>  <p>Here &quot;z&quot; is the transparent identifier - which I&#39;ve made somewhat more opaque by giving it a name. In the specification, the query translations are performed in terms of &quot;*&quot; - which clearly isn&#39;t a valid identifier, but which stands in for the transparent one.</p>  <p>The good news about transparent identifiers is that most of the time you don&#39;t need to think of them at all. They simply let you have multiple range variables in scope at the same time. I find myself only bothering to think about them explicitly when I&#39;m trying to work out the full translation of a query expression which uses them. It&#39;s worth knowing about them to avoid being stumped by the concept of (say) a select clause being able to use multiple range variables, but that&#39;s all.</p>  <p>Now that we&#39;ve got the basic concept, we can move onto the final few clauses.</p>  <h3>Secondary &quot;from&quot; clauses</h3>  <p>We&#39;ve seen that the introductory &quot;from&quot; clause isn&#39;t actually translated into a method call, but any subsequent ones are. The syntax is still the same, but the translation uses SelectMany. In many cases this is used just like a cross-join (Cartesian product) but it&#39;s more flexible than that, as the &quot;inner&quot; sequence introduced by the secondary &quot;from&quot; clause can depend on the current value from the &quot;outer&quot; sequence. Here&#39;s an example of that. with the call to SelectMany in the translation:</p>  <div class="code"><span class="InlineComment">// Query expression</span>     <br /><span class="Linq">from</span> parent <span class="Statement">in</span> adults     <br /><span class="Linq">from</span> child <span class="Statement">in</span> parent.Children     <br /><span class="Linq">where</span> child.Gender == Gender.Male     <br /><span class="Linq">select</span> child.Name + <span class="String">&quot; is a son of &quot;</span> + parent.Name     <br />    <br /><span class="InlineComment">// Translation (using z for the transparent identifier)</span>     <br />adults.SelectMany(parent =&gt; parent.Children,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (parent, child) =&gt; <span class="Keyword">new</span> { parent, child })     <br />&#160;&#160;&#160;&#160;&#160; .Where(z =&gt; z.child.Gender == Gender.Male)     <br />&#160;&#160;&#160;&#160;&#160; .Select(z =&gt; z.child.Name + <span class="String">&quot; is a son of &quot;</span> + z.parent.Name; </div>  <p>Again we can see the effect of the transparent identifier - an anonymous type is introduced to propagate the { parent, child } tuple through the rest of the query.</p>  <p>There&#39;s a special case, however - if &quot;the rest of the query&quot; is <em>just</em> a &quot;select&quot; clause, we don&#39;t need the anonymous type. We can just apply the projection directly in the SelectMany call. Here&#39;s a similar example, but this time without the &quot;where&quot; clause:</p>  <div class="code"><span class="InlineComment">// Query expression</span>     <br /><span class="Linq">from</span> parent <span class="Statement">in</span> adults     <br /><span class="Linq">from</span> child <span class="Statement">in</span> parent.Children     <br /><span class="Linq">select</span> child.Name + <span class="String">&quot; is a child of &quot;</span> + parent.Name     <br />    <br /><span class="InlineComment">// Translation (using z for the transparent identifier)</span>     <br />adults.SelectMany(parent =&gt; parent.Children,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (parent, child) =&gt; child.Name + <span class="String">&quot; is a child of &quot;</span> + parent.Name) </div>  <p>This same trick is used in GroupJoin and Join, but I won&#39;t go into the details there. It&#39;s simpler to just provide examples which use the shortcut, instead of including unnecessary extra clauses just to force the transparent identifier to appear in the translation.</p>  <p>Note that just like the introductory &quot;from&quot; clause, you can specify a type for the range variable, which forces a call to &quot;Cast&lt;&gt;&quot;.</p>  <h3>Simple &quot;join&quot; clauses (no &quot;into&quot;)</h3>  <p>A &quot;join&quot; clause without an &quot;into&quot; part corresponds to a call to the Join method, which represents an inner equijoin. In some ways this is like an extra &quot;from&quot; clause with a &quot;where&quot; clause to provide the relevant filtering, but there&#39;s a significant difference: while the &quot;from&quot; clause (and SelectMany) allow you to project each element in the outer sequence to an inner sequence, in Join you merely provide the inner sequence directly, once. You also have to specify the two key selectors - one for the outer sequence, and one for the inner sequence. The general syntax is:</p>  <div class="code"><span class="Linq">join</span>&#160;<em>identifier</em>&#160;<span class="Statement">in</span>&#160;<em>inner-sequence</em>&#160;<span class="Linq">on</span>&#160;<em>outer-key-selector</em>&#160;<span class="Linq">equals</span>&#160;<em>inner-key-selector</em> </div>  <p>The identifier names the extra range variable introduced. Here&#39;s an example including the translation:</p>  <div class="code"><span class="InlineComment">// Query expression</span>     <br /><span class="Linq">from</span> customer <span class="Statement">in</span> customers     <br /><span class="Linq">join</span> order <span class="Statement">in</span> orders <span class="Linq">on</span> customer.Id <span class="Linq">equals</span> order.CustomerId     <br /><span class="Linq">select</span> customer.Name + <span class="String">&quot;: &quot;</span> + order.Price     <br />    <br /><span class="InlineComment">// Translation</span>     <br />customers.Join(orders,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; customer =&gt; customer.Id,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; order =&gt; order.CustomerId,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (customer, order) =&gt; customer.Name + <span class="String">&quot;: &quot;</span> + order.Price) </div>  <p>Note how if you put the key selectors the wrong way round, it&#39;s highly unlikely that the result will compile - the lambda expression for the outer sequence doesn&#39;t &quot;know about&quot; the inner sequence element, and vice versa. The C# compiler is even nice enough to guess the probable cause, and suggest the fix.</p>  <h3>Group joins - &quot;join ... into&quot;</h3>  <p>Group joins look exactly the same as inner joins, except they have an extra &quot;into <em>identifier</em>&quot; part at the end. Again, this introduces an extra range variable - but it&#39;s the identifier after the &quot;into&quot; which ends up in scope, not the one after &quot;join&quot;; that one is <em>only</em> used in the key selector. This is easier to see when we look at a sample translation:</p>  <div class="code"><span class="InlineComment">// Query expression</span>     <br /><span class="Linq">from</span> customer <span class="Statement">in</span> customers     <br /><span class="Linq">join</span> order <span class="Statement">in</span> orders <span class="Linq">on</span> customer.Id <span class="Linq">equals</span> order.CustomerId <span class="Linq">into</span> customerOrders     <br /><span class="Linq">select</span> customer.Name + <span class="String">&quot;: &quot;</span> + customerOrders.Count()     <br />    <br /><span class="InlineComment">// Translation</span>     <br />customers.GroupJoin(orders,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; customer =&gt; customer.Id,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; order =&gt; order.CustomerId,     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (customer, customerOrders) =&gt; customer.Name + <span class="String">&quot;: &quot;</span> + customerOrders.Count()) </div>  <p>If we had tried to refer to &quot;order&quot; in the select clause, the result would have been an error: it&#39;s not in scope any more. Note that this is <em>not</em> a query continuation unlike &quot;select ... into&quot; and &quot;group ... into&quot;. It introduces a new range variable, but all the previous range variables are still in scope.</p>  <p>That&#39;s it! That&#39;s all the translations that the C# compiler supports. VB&#39;s query expressions are rather richer - but I suspect that&#39;s at least <em>partly</em> because it&#39;s more painful to write the &quot;dot notation&quot; syntax in VB, as the lambda expression syntax isn&#39;t as nice as C#&#39;s.</p>  <h3>Translation cheat sheet</h3>  <p>I thought it would be useful to produce a short table of the kinds of clauses supported in query expressions, with the translation used by the C# compiler. The translation is given assuming a single range variable named &quot;x&quot; is in scope. I haven&#39;t given the alternative options where transparent identifiers are introduced - this table isn&#39;t meant to be a replacement for all the information above! (Likewise this doesn&#39;t mention the optimizations for degenerate query expressions or &quot;identity projection&quot; groupings.)</p>  <table border="1" cellspacing="0" cellpadding="2" width="849"><tbody>     <tr>       <td valign="top" width="449"><strong>Query expression clause</strong></td>        <td valign="top" width="398"><strong>Translation</strong></td>     </tr>      <tr>       <td valign="top" width="448">First &quot;from <em>[type]</em>&#160;<em>x</em> in <em>sequence</em>&quot;</td>        <td valign="top" width="399">Just &quot;sequence&quot; or &quot;sequence.Cast&lt;type&gt;()&quot;, but with the introduction of a range variable</td>     </tr>      <tr>       <td valign="top" width="448">Subsequent &quot;from&quot; clauses:          <br />&quot;from <em>[type] y</em> in <em>projection</em>&quot;</td>        <td valign="top" width="399">SelectMany(x =&gt; projection, (x, y) =&gt; new { x, y })          <br />or SelectMany(x =&gt; projection.Cast&lt;type&gt;(), (x, y) =&gt; new { x, y })</td>     </tr>      <tr>       <td valign="top" width="448">where <em>predicate</em></td>        <td valign="top" width="399">Where(x =&gt; predicate)</td>     </tr>      <tr>       <td valign="top" width="448">select <em>projection</em></td>        <td valign="top" width="399">Select(x =&gt; projection)</td>     </tr>      <tr>       <td valign="top" width="448">let y = projection</td>        <td valign="top" width="399">Select(x =&gt; new { x, y = projection })</td>     </tr>      <tr>       <td valign="top" width="448">orderby o1, o2 ascending, o3 descending          <br />(Each ordering may have descending or ascending specified explicitly; the default is ascending)</td>        <td valign="top" width="399">OrderBy(x =&gt; o1)          <br />.ThenBy(x =&gt; o2)           <br />.ThenByDescending(x =&gt; o3)</td>     </tr>      <tr>       <td valign="top" width="448">group <em>projection</em> by <em>key-selector</em></td>        <td valign="top" width="399">GroupBy(x =&gt; key-selector, x =&gt; projection)</td>     </tr>      <tr>       <td valign="top" width="448">join <em>y</em> in <em>inner-sequece            <br /></em>on <em>outer-key-selector</em> equals <em>inner-key-selector</em></td>        <td valign="top" width="399">Join(x =&gt; outer-key-selector,          <br />&#160;&#160;&#160; y =&gt; inner-key-selector,           <br />&#160;&#160;&#160; (x, y) =&gt; new { x, y })</td>     </tr>      <tr>       <td valign="top" width="448">join <em>y</em> in <em>inner-sequece            <br /></em>on <em>outer-key-selector</em> equals <em>inner-key-selector            <br /></em>into<em> z</em></td>        <td valign="top" width="399">GroupJoin(x =&gt; outer-key-selector,          <br />&#160;&#160;&#160; y =&gt; inner-key-selector,           <br />&#160;&#160;&#160; (x, z) =&gt; new { x, z })</td>     </tr>      <tr>       <td valign="top" width="448"><em>query1</em> into <em>y            <br />query2</em></td>        <td valign="top" width="400">(Translation in terms of a new query expression)          <br />from y in (query1)           <br />query2</td>     </tr>   </tbody></table>  <h3>Conclusion</h3>  <p>Hopefully that&#39;s made a certain amount of sense out of a fairly complicated topic. I find it&#39;s one of those &quot;aha!&quot; things - at some point it clicks, and then seems reasonably simple (aside from transparent identifiers, perhaps). Until that time, query expressions can be a bit magical.</p>  <p>As an aside, I have a sneaking suspicion that one of my first blog posts consisted of my initial impressions of LINQ, written in a plane on the way to the MVP conference in Seattle in September 2005. I would check, but I&#39;m finishing this post in another plane, this time on the way to San Francisco. I think I&#39;d have been somewhat surprised to be told in 2005 that I&#39;d still be writing blog posts about LINQ over five years later. Mind you, I can think of any number of things which have happened in the intervening years which would have astonished me to about the same degree.</p>  <p>Next time: some more thoughts on optimization. Oh, and I&#39;m likely to update my wishlist of extra operators as well, but within the existing post.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
