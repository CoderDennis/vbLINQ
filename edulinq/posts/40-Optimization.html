<html>
<head>
<title>Reimplementing LINQ to Objects: Part 40 - Optimization</title>
<link rel="stylesheet" href="codestyles.css" />
</head>
<body>
<h1>Part 40 - Optimization</h1>
<p>I&#39;m not an expert in optimization, and most importantly I don&#39;t have any real-world benchmarks to support this post, so please take it with a pinch of salt. That said, let&#39;s dive into what optimizations are available in LINQ to Objects.</p>  <h3>What do we mean by optimization?</h3>  <p>Just as we think of refactoring as changing the internal structure of code without changing its externally visible behaviour, optimization is the art/craft/science/voodoo of changing the <em>performance</em> of code without changing its externally visible behaviour. Sort of.</p>  <p>This requires two definitions: &quot;performance&quot; and &quot;externally visible behaviour&quot;. Neither are as simple as they sound. In almost all cases, performance is a trade-off, whether in speed vs memory, throughput vs latency, big-O complexity vs the factors <em>within</em> that complexity bound, and best case vs worst case.</p>  <p>In LINQ to Objects the &quot;best case vs worst case&quot; is the balance which we need to consider most often: in the cases where we can make a saving, how significant is that saving? How much does it cost in <em>every</em> case to make a saving <em>some</em> of the time? How often do we actually take the fast path?</p>  <p>Externally visible behaviour is even harder to pin down, because we definitely don&#39;t mean <em>all</em> externally visible behaviour. Almost all the optimizations in Edulinq are visible if you work hard enough - indeed, that&#39;s how I have unit tests for them. I can test that Count() uses the Count property of an ICollection&lt;T&gt; instead of iterating over it by creating an ICollection&lt;T&gt; implementation which works with Count but throws an exception if you try to iterate over it. I don&#39;t think we care about that sort of change to externally visible behaviour.</p>  <p>What we really mean is, &quot;If we use the code in a <em>sensible</em> way, will we get the same results with the optimized code as we would without the optimization?&quot; Much better. Nothing woolly about the term &quot;sensible&quot; at all, is there? More realistically, we could talk about a system where every type adheres to the contracts of every interface it implements - that would at least get rid of the examples used for unit testing. Still, even the performance of a system is externally visible... it&#39;s easy to tell the difference between an implementation of Count() which is optimized and one which isn&#39;t, if you&#39;ve got a list of 10 million items.</p>  <h3>How can we optimize in LINQ to Objects?</h3>  <p>Effectively we have one technique for significant optimization in LINQ to Objects: finding out that a sequence implements a more capable interface than IEnumerable&lt;T&gt;, and then using that interface. (Or in the case of my optimization for HashSet&lt;T&gt; and Contains, using a concrete type in the same way.) Count() is the most obvious example of this: if the sequence implements ICollection or ICollection&lt;T&gt;, then we can use the Count property on that interface and we&#39;re done. No need to iterate at all.</p>  <p>These are generally good optimizations because they allow us to transform an O(n) computation into an O(1) computation. That&#39;s a pretty big win when it&#39;s applicable, and the cost of checking is <em>reasonably</em> small. So long as we hit the right type once every so often - and particularly if in those cases the sequences are long - then it&#39;s a net gain. The performance characteristics are likely to be reasonably fixed here for any one program - it&#39;s not like we&#39;ll <em>sometimes</em> win and <em>sometimes</em> lose for a specific query... it&#39;s that for some queries we win and some we won&#39;t. If we were micro-optimizing, we might want a way of calling a &quot;non-optimized&quot; version which didn&#39;t even bother trying the optimization, because we know it will always fail. I would regard such an approach as a colossal waste of effort in the majority of cases.</p>  <p>Some optimizations are slightly less obvious, particularly because they don&#39;t offer a change in the big-O complexity, but can still make a significant difference. Take ToArray, for example. If we know the sequence is an IList&lt;T&gt; we can construct an array of exactly the right size and ask the list to copy the elements into it. Chances are that copy can be very efficient indeed, basically copying a whole block of bits from one place to another - and we know we won&#39;t need any resizing. Compare that with building up a buffer, resizing periodically including copying all the elements we&#39;ve already discovered. Every part of that process is going to be slower, but they&#39;re both O(n) operations really. This is a good example of where big-O notation doesn&#39;t tell the whole story. Again, the optimization is almost certainly a good one to make.</p>  <p>Then there are distinctly dodgy optimizations which <em>can</em> make a difference, but are unlikely to apply. My optimization for ElementAt and ElementAtOrDefault comes into play here. It&#39;s fine to check whether an object implements IList&lt;T&gt;, and use the indexer if so. That&#39;s an obvious win. But I have an extra optimization to exit quickly if we can find out that the given index is out of the bounds of the sequence. Unfortunately that optimization is only useful when:</p>  <ul>   <li>The sequence implements ICollection&lt;T&gt; or ICollection (but remember it has to implement IEnumerable&lt;T&gt; - there aren&#39;t many collections implementing <em>only</em> the non-generic ICollection, but the generic IEnumerable&lt;T&gt;) </li>    <li>The sequence <em>doesn&#39;t</em> implement IList&lt;T&gt; (which gets rid of almost all implementations of ICollection&lt;T&gt;) </li>    <li>The given index is <em>actually</em> greater than or equal to the size of the collection </li> </ul>  <p>All that comes at the cost of a couple of type checks... not a great cost, and we <em>do</em> potentially save an O(n) check for being given an index out of the bounds of the collection... but how often are we really going to make that win? This is where I&#39;d love to have something like <a href="http://research.google.com/pubs/pub36356.html">Dapper</a>, but applied to LINQ to Objects and running in a significant number of real-world projects, just logging in as light a way as possible how often we win, how often we lose, and how big the benefit is.</p>  <p>Finally, we come to the optimizations which don&#39;t make sense to me... such as the optimization for First in both Mono and LinqBridge. Both of these projects check whether the sequence is a list, so that they check the count and then use the indexer to fetch item 0 instead of calling GetEnumerator()/MoveNext()/Current. Now yes, there&#39;s a chance this avoids creating an extra object (although not always, <a href="http://msmvps.com/blogs/jon_skeet/archive/2011/01/18/gotcha-around-iterator-blocks.aspx">as we&#39;ve seen before</a>) - but they&#39;re both O(1) operations which are likely to be darned fast. At this point not only is the payback very small (if it even exists) but the whole operation is likely to be so fast that the tiny check for whether the object implements IList&lt;T&gt; is likely to become more significant. Oh, and then there&#39;s the extra code complexity - yes, that&#39;s only relevant to the implementers, but I&#39;d personally rather they spent their time on other things (like getting OrderByDescending to work properly... smirk). In other words, I think this is a <em>bad</em> target for optimization. At some point I&#39;ll try to do a quick analysis of just how often the collection has to implement IList&lt;T&gt; in order for it to be worth doing this - and whether the improvement is even measurable.</p>  <p>Of course there are other micro-optimizations available. When we don&#39;t need to fetch the current item (e.g. when skipping over items) let&#39;s just call MoveNext() instead of also assigning the return value of a property to a variable. I&#39;ve done that in various places in Edulinq, but <em>not</em> as an optimization strategy, which I suspect won&#39;t make a significant difference, but for readability - to make it clearer to the reader that we&#39;re just moving along the iterator, not examining the contents as we go.</p>  <p>The only other piece of optimization I think I&#39;ve performed in Edulinq is the &quot;yield the first results before sorting the rest&quot; part of my quicksort implementation. I&#39;m reasonably proud of that, at least conceptually. I don&#39;t think it really fits into any other bucket - it&#39;s just a matter of thinking about what we really need and when, deferring work just in case we never need to do it.</p>  <h3>What can we <em>not</em> optimize in LINQ to Objects?</h3>  <p>I&#39;ve found a few optimizations in both Edulinq and other implementations which I believe to be invalid.</p>  <p>Here&#39;s an example I happened to look at just this morning, when reviewing the code for <a href="http://msmvps.com/blogs/jon_skeet/archive/2011/01/02/reimplementing-linq-to-objects-part-23-take-skip-takewhile-skipwhile.aspx">Skip</a>:</p>  <div class="code"><span class="Linq">var</span> list = source <span class="Keyword">as</span> IList&lt;TSource&gt;;     <br /><span class="Statement">if</span> (list != <span class="Keyword">null</span>)     <br />{     <br />&#160;&#160;&#160; count = Math.Max(count, 0);     <br />&#160;&#160;&#160; <span class="InlineComment">// Note that &quot;count&quot; is the count of items to skip</span>     <br />&#160;&#160;&#160; <span class="Statement">for</span> (<span class="ValueType">int</span> index = count; index &lt; list.Count; index++)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">return</span> list[index];     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span class="Statement">yield</span>&#160;<span class="Statement">break</span>;     <br />} </div>  <p>If our sequence is a list, we can just skip straight to the right part of it and yield the items one at a time. That sounds great, but what if the list changes (or is even truncated!) while we&#39;re iterating over it? An implementation working with the simple iterator would usually throw an exception, as the change would invalidate the iterator. This is definitely a behavioural change. When I first wrote about Skip, I included this as a &quot;possible&quot; optimization - and actually turned it on in the Edulinq source code. I now believe it to be a mistake, and have removed it completely.</p>  <p>Another example is Reverse, and how it should behave. The documentation is fairly unclear, but when I ran the tests, the Mono implementation used an optimization whereby if the sequence is a list, it will just return items from the tail end using the indexer. (This has now been fixed - the Mono team is quick like that!) Again, that means that changes made to the list while iterating will be reflected in the reversed sequence. I believe the documentation for Reverse <em>ought</em> to be clear that:</p>  <ul>   <li>Execution is deferred: the input sequence isn&#39;t read when the method is called. </li>    <li>When the result sequence is first read by the caller, a snapshot is taken, and <em>that&#39;s</em> what&#39;s used to return the data. </li>    <li>If the result sequence is read more than once (i.e. GetEnumerator is called more than once) then a new snapshot is created each time - so changes to the input sequence between calls to GetEnumerator on the result sequence <em>will</em> be observed. </li> </ul>  <p>Now this is still not as precise as it might be in terms of what &quot;reading&quot; a sequence entails - in particular, a simple implementation of Reverse (as per Edulinq) will actually take the snapshot on the first call to MoveNext() on the iterator returned by GetEnumerator() - but that&#39;s probably not too bad. The snapshotting behaviour itself is important though, and should be made explicit in my opinion.</p>  <p>The problem with both of these &quot;optimizations&quot; is arguably that they&#39;re applying list-based optimizations <em>within an iterator block used for deferred execution</em>. Optimizing for lists either upfront at the point of the initial method call or within an immediate execution operator (Count, ToList etc) is fine, because we assume the sequence won&#39;t change during the course of the method&#39;s execution. We can&#39;t make that assumption with an iterator block, because the flow of the code is very different: our code is visited repeatedly based on the caller&#39;s use of MoveNext().</p>  <h5>Sequence identity</h5>  <p>Another aspect of behaviour which isn&#39;t well-specified is that of identity. When is it valid for an operator to return the input sequence itself as the result sequence?</p>  <p>In the Microsoft implementation, this can occur in two operators: AsEnumerable (which <em>always</em> returns the input sequence reference, even if it&#39;s null) and Cast (which returns the original reference only if it actually implements IEnumerable&lt;TResult&gt;).</p>  <p>In Edulinq, I have two other operators which can return the input sequence: OfType (only if the original reference implements IEnumerable&lt;TResult&gt; and TResult is a non-nullable value type) and Skip (if you provide a count which is zero or negative). Are these valid optimizations? Let&#39;s think about why we might <em>not</em> want them to be...</p>  <p>If you&#39;re returning a sequence from one layer of your code to another, you usually<em> </em>want that sequence to be viewed <em>only</em> as a sequence. In particular, if it&#39;s backed by a List&lt;T&gt;, you don&#39;t want callers casting to List&lt;T&gt; and modifying the list. With any operator implemented by an iterator block, that&#39;s fine - the object returned from the operator has no accessible reference to its input, and the type itself only implements IEnumerable&lt;T&gt; (and IEnumerator&lt;T&gt;, and IDisposable, etc - but not IList&lt;T&gt;). It&#39;s not so good if the operator decides it&#39;s okay to return the original reference.</p>  <p>The C# language specification refers to this in the section about query expression translation: a no-op projection at the end of a query can be omitted <em>if and only if there are other operators in the query</em>. So a query expression of &quot;from foo in bar select foo&quot; will translate to &quot;bar.Select(foo =&gt; foo)&quot; but if we had a &quot;where&quot; clause in the query, the Select call would be removed. It&#39;s worth noting that the call to &quot;Cast&quot; generated when you explicitly specify the type of a range variable is <em>not</em> enough to prevent the &quot;no-op&quot; projection from being generated... it&#39;s almost as if the C# team &quot;knows&quot; that Cast can leak sequence identity whereas Where can&#39;t.</p>  <p>Personally I think that the &quot;hiding&quot; of the input sequence should be guaranteed where it makes sense to do so, and explicitly <em>not</em> guaranteed otherwise. We could also add an operator of something like &quot;HideIdentity&quot; which would simply (and unconditionally) add an extra iterator block into the pipeline. That way library authors wouldn&#39;t have to guess, and would have a clear way of expressing their intention. Using Select(x =&gt; x) or Skip(0) is <em>not</em> clear, and in the case of Skip it would even be pointless when using Edulinq.</p>  <p>As for whether my optimizations are valid - that&#39;s up for debate, really. It seems hard to justify why leaking sequence identity would be okay for Cast but <em>not</em> okay for OfType, whereas I think there&#39;s a better case for claiming that Skip should always hide sequence identity.</p>  <h5>The Contains issue...</h5>  <p>If you remember, I have a disagreement around what Contains should do when you don&#39;t provide an equality comparer, and when the sequence implements ICollection&lt;T&gt;. I believe it should be consistent with the rest of LINQ to Objects, which <em>always</em> uses the default equality comparer for the element type when it needs one but the user hasn&#39;t specified one. Everyone else (Microsoft, Mono, LinqBridge) has gone with delegating to the collection&#39;s implementation of ICollection&lt;T&gt;.Contains. That plays well in terms of consistency of what happens if you call Contains on that object, so that it doesn&#39;t matter what the compile-time type is. That&#39;s a debate to go into in another post, but I just want to point out that this is <em>not</em> an example of optimization. In some cases it may be faster (notably for HashSet&lt;T&gt;) but it stands a <em>very</em> good chance of changing the behaviour. There is absolutely nothing to suggest that the equality comparer used by ICollection&lt;T&gt; should be the default one for the type - and in some cases it definitely isn&#39;t.</p>  <p>It&#39;s therefore a matter of what <em>result</em> we want to get, not how to get that result faster. It&#39;s correctness, not optimization - but both the LinqBridge and Mono tests which fail for Edulinq are called &quot;Contains_CollectionOptimization_ReturnsTrueWithoutEnumerating&quot; - and I think that shows a mistaken way of thinking about this.</p>  <h3>Can we go further?</h3>  <p>I&#39;ve been considering a couple of optimizations which I believe to be perfectly legitimate, but which none of the implementations I&#39;ve seen have used. One reason I haven&#39;t implemented them myself yet is that they will reduce the effectiveness of all my unit tests. You see, I&#39;ve generally used Enumerable.Range as a good way of testing a non-list-based sequence... but what&#39;s to stop Range and Repeat being implemented <em>as</em> IList&lt;T&gt; implementations?</p>  <p>All the non-mutating members are easy to implement, and we can just throw exceptions from the mutating members (as other read-only collections do).</p>  <p>Would this be more efficient? Well yes, if you ever performed a Count(), ElementAt(), ToArray(), ToList() etc operation on a range or a repeated element... but how often is <em>that</em> going to happen? I suspect it&#39;s pretty rare - probably rare enough not to make it worth my time, particularly when you then consider all the tests that would have to be rewritten to use something other than Range when I wanted a non-list sequence...</p>  <h3>Conclusion</h3>  <p>Surprise, surprise - doing optimization well is difficult. When it&#39;s obvious what <em>can</em> be done, it&#39;s not obvious what <em>should</em> be done... and sometimes it&#39;s not even what is valid in the first place.</p>  <p>Note that none of this has really talked about data structures and algorithms. I looked at some options when implementing ordering, and I&#39;m <em>still</em> thinking about the best approach for implementing TopBy (probably either a heap or a self-balancing tree - something which could take advantage of the size being constant would be nice) - but <em>in general</em> the optimizations here haven&#39;t required any cunning knowledge of computer science. That&#39;s quite a good thing, because it&#39;s many years since I&#39;ve studied CS seriously...</p>  <p>I suspect that with this post more than almost any other, I&#39;m likely to want to add extra items in the future (or amend mistakes which reveal my incompetence). Watch this space.</p>  <p>Next up, I think it would be worth revisiting query expressions from scratch. Anyone who&#39;s read C# in Depth or has followed this blog for long enough is likely to be able to skip it, but I think the series would be incomplete without a quick dive into the compiler translations involved.</p><div style="clear:both;"></div>
<hr />
<p>Back to the <a href="index.html">table of contents</a>.</p>
</body>
</html>
